<!DOCTYPE html>

<html>
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width" />
    <title>Handbook - Welcome to TypeScript</title>
    <link rel="stylesheet" href="/Content/bootstrap.min.css" />    
    <link type="text/css" rel="stylesheet" href="/content/TsWeb2.css" />
    <link rel="stylesheet" href="/Content/tsmig.css" />
    <link rel="icon" href="/favicon.ico" type="image/vnd.microsoft.icon" sizes="48x48" />
    <link rel="icon" href="/favicon.ico" sizes="32x32 48x48" type="image/vnd.microsoft.icon">
    <link rel="icon" href="/favicon16.png" type="image/png" sizes="16x16" />
    <link rel="icon" href="/favicon32.png" type="image/png" sizes="32x32" />
    <link rel="icon" href="/favicon48.png" type="image/png" sizes="48x48" />
    <link rel="icon" href="/favicon64.png" type="image/png" sizes="64x64" />
    <link rel="icon" href="/favicon128.png" type="image/png" sizes="128x128" />
    <script type="text/javascript" src="/Scripts/jquery-2.1.0.min.js"></script>
    <script type="text/javascript" src="/Scripts/bootstrap.js"></script>
    <script>

        function reportAction(n, t, i) {
            return ga("send", "event", "click", n, t, i), !0
        }

        (function (i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date(); a = s.createElement(o),
            m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
        })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

        ga('create', 'UA-64034028-1', 'auto');

        // strip off trailing slashes
        var pathnameWithoutTrailingSlash = window.location.pathname.toLowerCase();
        var pathnameLength = pathnameWithoutTrailingSlash.length;
        if (pathnameLength > 1 && pathnameWithoutTrailingSlash.lastIndexOf("/") == pathnameLength - 1) {
            pathnameWithoutTrailingSlash = pathnameWithoutTrailingSlash.substring(0, pathnameLength - 1);
        }
        ga("send", "pageview", pathnameWithoutTrailingSlash);

        window.onhashchange = function () {
            ga("send", "pageview", window.location.pathname.toLowerCase() + window.location.hash);
        };

    </script>
</head>
<body class="handbook" >
    <nav>
        <div class="centered-container">
            <div class="clearfix">
                <a id="homelink" class="selected" href="/" title="TypeScript">
                    <div>TypeScript</div>

                </a>
                <a id="tutorial-link" class="minor with-subnav" href="/Tutorial">learn</a>
                <div class="subnav" id="sn-learn" data-owner="#tutorial-link" data-hover-class="show-learn">
                    <a id="tutorial-subnav-link" class="sub" href="/Tutorial" title="Learn TypeScript with a Guided Tutorial">tutorial</a>
                    <a id="handbook-subnav-link" class="sub" href="/Handbook" title="Deep dive into all of TypeScript's features">handbook</a>
                    <a id="samples-subnav-link" class="sub" href="/Samples" title="See TypeScript in action in these samples">samples</a>
                    <a href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md" title="Read the spec">language spec</a>
                </div>
                <a id="playground-link" class="minor" href="/Playground">play</a>
                <div class="subnav" id="sn-play" data-owner="#playground-link" data-hover-class="show-play" data-allow-click="true"></div>
                <a id="dl-link" class="minor with-subnav" href="/#Download">download</a>
                <div class="subnav" id="sn-dl" data-owner="#dl-link" data-hover-class="show-dl">
                    <a class="sub" style="font-family: Consolas, sans-serif; background-color: #eee;">npm i -g typescript</a>
                    <a class="sub" href="https://www.microsoft.com/en-us/download/details.aspx?id=48739" onclick="reportAction('Download', 'VS2013', {'location': 'header'})">VS2013</a>
                    <a class="sub" href="https://www.microsoft.com/en-us/download/details.aspx?id=48593" onclick="reportAction('Download', 'VS2015', {'location': 'header'})">VS2015</a>
                    <a class="sub" href="https://github.com/Microsoft/TypeScript" onclick="reportAction('Download', 'source', {'location': 'header'})">the source</a>
                </div>
                <a id="interact-link" class="minor with-subnav" href="https://github.com/Microsoft/TypeScript">interact</a>
                <div class="subnav" id="sn-int" data-owner="#interact-link" data-hover-class="show-int">
                    <a class="sub" href="http://stackoverflow.com/questions/tagged/typescript">Stack Overflow</a>
                    <a class="sub" href="https://github.com/Microsoft/TypeScript/issues">file bug</a>
                    <a class="sub" href="http://blogs.msdn.com/b/typescript/">blog</a>
                    <a class="sub" href="https://github.com/borisyankov/DefinitelyTyped">DefinitelyTyped</a>
                </div>
            </div>
        </div>
    </nav>

    

<div class="intro"></div>
<div id="handbook-nav-container">
    <div style="max-width: 1200px; margin: 0 auto;">
        <div class="row">
            <div class="col-md-offset-0 col-md-3 col-xs-8 col-xs-offset-2 col-sm-8 col-sm-offset-2">
                <div class="hidden-print" role="complementary" style="">
                    <ul class="hb-main">
                            <li>
                                <a href="#basic-types" class="hbn-main">Basic Types</a>
                                <ul class="hb-sub hidden-sm hidden-xs hidden-sub">
                                        <li><a href="#basic-types-boolean" class="hbn-sub">Boolean</a></li>
                                        <li><a href="#basic-types-number" class="hbn-sub">Number</a></li>
                                        <li><a href="#basic-types-string" class="hbn-sub">String</a></li>
                                        <li><a href="#basic-types-array" class="hbn-sub">Array</a></li>
                                        <li><a href="#basic-types-enum" class="hbn-sub">Enum</a></li>
                                        <li><a href="#basic-types-any" class="hbn-sub">Any</a></li>
                                        <li><a href="#basic-types-void" class="hbn-sub">Void</a></li>
                                </ul>
                            </li>
                            <li>
                                <a href="#interfaces" class="hbn-main">Interfaces</a>
                                <ul class="hb-sub hidden-sm hidden-xs hidden-sub">
                                        <li><a href="#interfaces-our-first-interface-" class="hbn-sub">Our First Interface </a></li>
                                        <li><a href="#interfaces-optional-properties" class="hbn-sub">Optional Properties</a></li>
                                        <li><a href="#interfaces-function-types" class="hbn-sub">Function Types</a></li>
                                        <li><a href="#interfaces-array-types" class="hbn-sub">Array Types</a></li>
                                        <li><a href="#interfaces-class-types" class="hbn-sub">Class Types</a></li>
                                        <li><a href="#interfaces-extending-interfaces" class="hbn-sub">Extending Interfaces</a></li>
                                        <li><a href="#interfaces-hybrid-types" class="hbn-sub">Hybrid Types</a></li>
                                </ul>
                            </li>
                            <li>
                                <a href="#classes" class="hbn-main">Classes</a>
                                <ul class="hb-sub hidden-sm hidden-xs hidden-sub">
                                        <li><a href="#classes-classes" class="hbn-sub">Classes</a></li>
                                        <li><a href="#classes-inheritance" class="hbn-sub">Inheritance</a></li>
                                        <li><a href="#classes-privatepublic-modifiers" class="hbn-sub">Private/Public modifiers</a></li>
                                        <li><a href="#classes-accessors" class="hbn-sub">Accessors</a></li>
                                        <li><a href="#classes-static-properties" class="hbn-sub">Static Properties</a></li>
                                        <li><a href="#classes-advanced-techniques" class="hbn-sub">Advanced Techniques</a></li>
                                </ul>
                            </li>
                            <li>
                                <a href="#modules" class="hbn-main">Modules</a>
                                <ul class="hb-sub hidden-sm hidden-xs hidden-sub">
                                        <li><a href="#modules-splitting-across-files" class="hbn-sub">Splitting Across Files</a></li>
                                        <li><a href="#modules-going-external" class="hbn-sub">Going External</a></li>
                                        <li><a href="#modules-export-" class="hbn-sub">Export =</a></li>
                                        <li><a href="#modules-alias" class="hbn-sub">Alias</a></li>
                                        <li><a href="#modules-optional-module-loading-and-other-advanced-loading-scenarios" class="hbn-sub">Optional Module Loading and Other Advanced Loading Scenarios</a></li>
                                        <li><a href="#modules-working-with-other-javascript-libraries" class="hbn-sub">Working with Other JavaScript Libraries</a></li>
                                        <li><a href="#modules-pitfalls-of-modules" class="hbn-sub">Pitfalls of Modules</a></li>
                                </ul>
                            </li>
                            <li>
                                <a href="#functions" class="hbn-main">Functions</a>
                                <ul class="hb-sub hidden-sm hidden-xs hidden-sub">
                                        <li><a href="#functions-functions" class="hbn-sub">Functions</a></li>
                                        <li><a href="#functions-function-types" class="hbn-sub">Function Types</a></li>
                                        <li><a href="#functions-optional-and-default-parameters" class="hbn-sub">Optional and Default Parameters</a></li>
                                        <li><a href="#functions-rest-parameters" class="hbn-sub">Rest Parameters</a></li>
                                        <li><a href="#functions-lambdas-and-using-39this39" class="hbn-sub">Lambdas and using &#39;this&#39;</a></li>
                                        <li><a href="#functions-overloads" class="hbn-sub">Overloads</a></li>
                                </ul>
                            </li>
                            <li>
                                <a href="#generics" class="hbn-main">Generics</a>
                                <ul class="hb-sub hidden-sm hidden-xs hidden-sub">
                                        <li><a href="#generics-hello-world-of-generics" class="hbn-sub">Hello World of Generics</a></li>
                                        <li><a href="#generics-working-with-generic-type-variables" class="hbn-sub">Working with Generic Type Variables</a></li>
                                        <li><a href="#generics-generic-types" class="hbn-sub">Generic Types</a></li>
                                        <li><a href="#generics-generic-classes" class="hbn-sub">Generic Classes</a></li>
                                        <li><a href="#generics-generic-constraints" class="hbn-sub">Generic Constraints</a></li>
                                </ul>
                            </li>
                            <li>
                                <a href="#common-errors" class="hbn-main">Common Errors</a>
                                <ul class="hb-sub hidden-sm hidden-xs hidden-sub">
                                        <li><a href="#common-errors-commonly-confusing-errors" class="hbn-sub">Commonly Confusing Errors</a></li>
                                </ul>
                            </li>
                            <li>
                                <a href="#mixins" class="hbn-main">Mixins</a>
                                <ul class="hb-sub hidden-sm hidden-xs hidden-sub">
                                        <li><a href="#mixins-mixin-sample" class="hbn-sub">Mixin sample</a></li>
                                        <li><a href="#mixins-understanding-the-sample" class="hbn-sub">Understanding the sample</a></li>
                                </ul>
                            </li>
                            <li>
                                <a href="#declaration-merging" class="hbn-main">Declaration Merging</a>
                                <ul class="hb-sub hidden-sm hidden-xs hidden-sub">
                                        <li><a href="#declaration-merging-basic-concepts" class="hbn-sub">Basic Concepts</a></li>
                                        <li><a href="#declaration-merging-merging-interfaces" class="hbn-sub">Merging Interfaces</a></li>
                                        <li><a href="#declaration-merging-merging-modules" class="hbn-sub">Merging Modules</a></li>
                                        <li><a href="#declaration-merging-merging-modules-with-classes-functions-and-enums" class="hbn-sub">Merging Modules with Classes, Functions, and Enums</a></li>
                                        <li><a href="#declaration-merging-disallowed-merges" class="hbn-sub">Disallowed Merges</a></li>
                                </ul>
                            </li>
                            <li>
                                <a href="#type-inference" class="hbn-main">Type Inference</a>
                                <ul class="hb-sub hidden-sm hidden-xs hidden-sub">
                                        <li><a href="#type-inference-basics" class="hbn-sub">Basics</a></li>
                                        <li><a href="#type-inference-best-common-type" class="hbn-sub">Best common type</a></li>
                                        <li><a href="#type-inference-contextual-type" class="hbn-sub">Contextual Type</a></li>
                                </ul>
                            </li>
                            <li>
                                <a href="#type-compatibility" class="hbn-main">Type Compatibility</a>
                                <ul class="hb-sub hidden-sm hidden-xs hidden-sub">
                                        <li><a href="#type-compatibility-starting-out" class="hbn-sub">Starting out</a></li>
                                        <li><a href="#type-compatibility-comparing-two-functions" class="hbn-sub">Comparing two functions</a></li>
                                        <li><a href="#type-compatibility-enums" class="hbn-sub">Enums</a></li>
                                        <li><a href="#type-compatibility-classes" class="hbn-sub">Classes</a></li>
                                        <li><a href="#type-compatibility-generics" class="hbn-sub">Generics</a></li>
                                        <li><a href="#type-compatibility-advanced-topics" class="hbn-sub">Advanced Topics</a></li>
                                </ul>
                            </li>
                            <li>
                                <a href="#writing-dts-files" class="hbn-main">Writing .d.ts files</a>
                                <ul class="hb-sub hidden-sm hidden-xs hidden-sub">
                                        <li><a href="#writing-dts-files-guidelines-and-specifics" class="hbn-sub">Guidelines and Specifics</a></li>
                                        <li><a href="#writing-dts-files-examples" class="hbn-sub">Examples</a></li>
                                </ul>
                            </li>
                    </ul>
                </div>
            </div>
            <div class="col-md-offset-0 col-md-9 col-xs-10 col-xs-offset-1 col-sm-10 col-sm-offset-1"></div>
        </div> <!-- .center-container -->
    </div> <!-- outer container -->
</div>
<div style="width: 100%;">
    <div style="max-width: 1200px; margin: 0 auto;">
        <div class="row">
            <div class="col-md-offset-0 col-md-3 col-xs-8 col-xs-offset-2 col-sm-8 col-sm-offset-2">

            </div>
            <div class="col-md-offset-0 col-md-9 col-xs-10 col-xs-offset-1 col-sm-10 col-sm-offset-1">
<br>
<hr>
<h1 class="has-hash-nav" data-hash-nav="basic-types">Basic Types</h1>
For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like. In TypeScript, we support much the same types as you would expected in JavaScript, with a convenient enumeration
 type thrown in to help things along.<br>
<h2 class="has-hash-nav" data-hash-nav="basic-types-boolean">Boolean</h2>
The most basic datatype is the simple true/false value, which JavaScript and TypeScript (as well as other languages) call a &#39;boolean&#39; value.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> isDone: <span style="color:Blue">boolean</span> = <span style="color:Blue">false</span>;
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="basic-types-number">Number</h2>
As in JavaScript, all numbers in TypeScript are floating point values. These floating point numbers get the type &#39;number&#39;.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> height: number = 6;
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="basic-types-string">String</h2>
Another fundamental part of creating programs in JavaScript for webpages and servers alike is working with textual data. As in other languages, we use the type &#39;string&#39; to refer to these textual datatypes. Just like JavaScript, TypeScript also uses
 the double quote (&quot;) or single quote (&#39;) to surround string data.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> name: string = <span style="color:#A31515">&quot;bob&quot;</span>;
name = <span style="color:#A31515">&#39;smith&#39;</span>;
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="basic-types-array">Array</h2>
TypeScript, like JavaScript, allows you to work with arrays of values. Array types can be written in one of two ways. In the first, you use the type of the elements followed by &#39;[]&#39; to denote an array of that element type:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> list:number[] = [1, 2, 3];
</pre>
</div>
<br>
The second way uses a generic array type, Array&lt;elemType&gt;:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> list:Array&lt;number&gt; = [1, 2, 3];
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="basic-types-enum">Enum</h2>
A helpful addition to the standard set of datatypes from JavaScript is the &#39;enum&#39;. Like languages like C#, an enum is a way of giving more friendly names to sets of numeric values.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">enum</span> Color {Red, Green, Blue};
<span style="color:Blue">var</span> c: Color = Color.Green;
</pre>
</div>
<br>
By default, enums begin numbering their members starting at 0. You can change this by manually setting the value of one its members. For example, we can start the previous example at 1 instead of 0:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">enum</span> Color {Red = 1, Green, Blue};
<span style="color:Blue">var</span> c: Color = Color.Green;
</pre>
</div>
<br>
Or, even manually set all the values in the enum:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">enum</span> Color {Red = 1, Green = 2, Blue = 4};
<span style="color:Blue">var</span> c: Color = Color.Green;
</pre>
</div>
<br>
A handy feature of enums is that you can also go from a numeric value to the name of that value in the enum. For example, if we had the value 2 but weren&#39;t sure which that mapped to in the Color enum above, we could look up the corresponding name:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">enum</span> Color {Red = 1, Green, Blue};
<span style="color:Blue">var</span> colorName: string = Color[2];

alert(colorName);
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="basic-types-any">Any</h2>
We may need to describe the type of variables that we may not know when we are writing the application. These values may come from dynamic content, eg from the user or 3rd party library. In these cases, we want to opt-out of type-checking and let the values
 pass through compile-time checks. To do so, we label these with the &#39;any&#39; type:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> notSure: any = 4;
notSure = <span style="color:#A31515">&quot;maybe a string instead&quot;</span>;
notSure = <span style="color:Blue">false</span>; <span style="color:Green">// okay, definitely a boolean</span>
</pre>
</div>
<br>
The &#39;any&#39; type is a powerful way to work with existing JavaScript, allowing you to gradually opt-in and opt-out of type-checking during compilation.<br>
<br>
The &#39;any&#39; type is also handy if you know some part of the type, but perhaps not all of it. For example, you may have an array but the array has a mix of different types:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> list:any[] = [1, <span style="color:Blue">true</span>, <span style="color:#A31515">&quot;free&quot;</span>];

list[1] = 100;
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="basic-types-void">Void</h2>
Perhaps the opposite in some ways to &#39;any&#39; is &#39;void&#39;, the absence of having any type at all. You may commonly see this as the return type of functions that do not return a value:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> warnUser(): <span style="color:Blue">void</span> {
    alert(<span style="color:#A31515">&quot;This is my warning message&quot;</span>);
}
</pre>
</div>
<br>
<hr>
<h1 class="has-hash-nav" data-hash-nav="interfaces">Interfaces</h1>
One of TypeScript&#39;s core principles is that type-checking focuses on the &#39;shape&#39; that values have. This is sometimes called &quot;duck typing&quot; or &quot;structural subtyping&quot;. In TypeScript, interfaces fill the role of naming these types,
 and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.
<br>
<h2 class="has-hash-nav" data-hash-nav="interfaces-our-first-interface-">Our First Interface </h2>
The easiest way to see how interfaces work is to start with a simple example:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> printLabel(labelledObj: {label: string}) {
  console.log(labelledObj.label);
}

<span style="color:Blue">var</span> myObj = {size: 10, label: <span style="color:#A31515">&quot;Size 10 Object&quot;</span>};
printLabel(myObj);
</pre>
</div>
<br>
The type-checker checks the call to &#39;printLabel&#39;. The &#39;printLabel&#39; function has a single parameter that requires that the object passed in has a property called &#39;label&#39; of type string. Notice that our object actually has more properties
 than this, but the compiler only checks to that <i>at least</i> the ones required are present and match the types required.
<br>
<br>
We can write the same example again, this time using an interface to describe the requirement of having the &#39;label&#39; property that is a string:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> LabelledValue {
  label: string;
}

<span style="color:Blue">function</span> printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label);
}

<span style="color:Blue">var</span> myObj = {size: 10, label: <span style="color:#A31515">&quot;Size 10 Object&quot;</span>};
printLabel(myObj);
</pre>
</div>
<br>
The interface &#39;LabelledValue&#39; is a name we can now use to describe the requirement in the previous example. It still represents having a single property called &#39;label&#39; that is of type string. Notice we didn&#39;t have to explicitly say that
 the object we pass to &#39;printLabel&#39; implements this interface like we might have to in other languages. Here, it&#39;s only the shape that matters. If the object we pass to the function meets the requirements listed, then it&#39;s allowed.<br>
<br>
It&#39;s worth pointing out that the type-checker does not require that these properties come in any sort of order, only that the properties the interface requires are present and have the required type.<br>
<h2 class="has-hash-nav" data-hash-nav="interfaces-optional-properties">Optional Properties</h2>
Not all properties of an interface may be required. Some exist under certain conditions or may not be there at all. These optional properties are popular when creating patterns like &quot;option bags&quot; where the user passes an object to a function that
 only has a couple properties filled in.<br>
<br>
Here&#39;s as example of this pattern:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> SquareConfig {
  color?: string;
  width?: number;
}

<span style="color:Blue">function</span> createSquare(config: SquareConfig): {color: string; area: number} {
  <span style="color:Blue">var</span> newSquare = {color: <span style="color:#A31515">&quot;white&quot;</span>, area: 100};
  <span style="color:Blue">if</span> (config.color) {
    newSquare.color = config.color;
  }
  <span style="color:Blue">if</span> (config.width) {
    newSquare.area = config.width * config.width;
  }
  <span style="color:Blue">return</span> newSquare;
}

<span style="color:Blue">var</span> mySquare = createSquare({color: <span style="color:#A31515">&quot;black&quot;</span>});
</pre>
</div>
<br>
Interfaces with optional properties are written similar to other interfaces, which each optional property denoted with a &#39;?&#39; as part of the property declaration.
<br>
<br>
The advantage of optional properties is that you can describe these possibly available properties while still also catching properties that you know are not expected to be available. For example, had we mistyped the name of the property we passed to &#39;createSquare&#39;,
 we would get an error message letting us know:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> SquareConfig {
  color?: string;
  width?: number;
}

<span style="color:Blue">function</span> createSquare(config: SquareConfig): {color: string; area: number} {
  <span style="color:Blue">var</span> newSquare = {color: <span style="color:#A31515">&quot;white&quot;</span>, area: 100};
  <span style="color:Blue">if</span> (config.color) {
    newSquare.color = config.collor;  <span style="color:Green">// Type-checker can catch the mistyped name here</span>
  }
  <span style="color:Blue">if</span> (config.width) {
    newSquare.area = config.width * config.width;
  }
  <span style="color:Blue">return</span> newSquare;
}

<span style="color:Blue">var</span> mySquare = createSquare({color: <span style="color:#A31515">&quot;black&quot;</span>});  
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="interfaces-function-types">Function Types</h2>
Interfaces are capable of describing the wide range of shapes that JavaScript objects can take. In addition to describing an object with properties, interfaces are also capable of describing function types.<br>
<br>
To describe a function type with an interface, we give the interface a call signature. This is like a function declaration with only the parameter list and return type given.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> SearchFunc {
  (source: string, subString: string): <span style="color:Blue">boolean</span>;
}
</pre>
</div>
<br>
Once defined, we can use this function type interface like we would other interfaces. Here, we show how you can create a variable of a function type and assign it a function value of the same type.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> mySearch: SearchFunc;
mySearch = <span style="color:Blue">function</span>(source: string, subString: string) {
  <span style="color:Blue">var</span> result = source.search(subString);
  <span style="color:Blue">if</span> (result == -1) {
    <span style="color:Blue">return</span> <span style="color:Blue">false</span>;
  }
  <span style="color:Blue">else</span> {
    <span style="color:Blue">return</span> <span style="color:Blue">true</span>;
  }
}
</pre>
</div>
<br>
For function types to correctly type-check, the name of the parameters do not need to match. We could have, for example, written the above example like this:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> mySearch: SearchFunc;
mySearch = <span style="color:Blue">function</span>(src: string, sub: string) {
  <span style="color:Blue">var</span> result = src.search(sub);
  <span style="color:Blue">if</span> (result == -1) {
    <span style="color:Blue">return</span> <span style="color:Blue">false</span>;
  }
  <span style="color:Blue">else</span> {
    <span style="color:Blue">return</span> <span style="color:Blue">true</span>;
  }
}
</pre>
</div>
<br>
Function parameters are checked one at a time, with the type in each corresponding parameter position checked against each other. Here, also, the return type of our function expression is implied by the values it returns (here
<i>false</i> and <i>true</i>). Had the function expression returned numbers or strings, the type-checker would have warned us that return type doesn&#39;t match the return type described in the SearchFunc interface.<br>
<h2 class="has-hash-nav" data-hash-nav="interfaces-array-types">Array Types</h2>
Similarly to how we can use interfaces to describe function types, we can also describe array types. Array types have an &#39;index&#39; type that describes the types allowed to index the object, along with the corresponding return type for accessing the index.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> StringArray {
  [index: number]: string;
}

<span style="color:Blue">var</span> myArray: StringArray;
myArray = [<span style="color:#A31515">&quot;Bob&quot;</span>, <span style="color:#A31515">&quot;Fred&quot;</span>];
</pre>
</div>
<br>
There are two types of supported index types: string and number. It is possible to support both types of index, with the restriction that the type returned from the numeric index must be a subtype of the type returned from the string index.<br>
<br>
While index signatures are a powerful way to describe the array and &#39;dictionary&#39; pattern, they also enforce that all properties match their return type. In this example, the property does not match the more general index, and the type-checker gives
 an error:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> Dictionary {
  [index: string]: string;
  length: number;    <span style="color:Green">// error, the type of &#39;length&#39; is not a subtype of the indexer</span>
} 
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="interfaces-class-types">Class Types</h2>
<h3>Implementing an interface</h3>
One of the most common uses of interfaces in languages like C# and Java, that of explicitly enforcing that a class meets a particular contract, is also possible in TypeScript.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> ClockInterface {
    currentTime: Date;
}

<span style="color:Blue">class</span> Clock <span style="color:Blue">implements</span> ClockInterface  {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
</pre>
</div>
<br>
You can also describe methods in an interface that are implemented in the class, as we do with &#39;setTime&#39; in the below example:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

<span style="color:Blue">class</span> Clock <span style="color:Blue">implements</span> ClockInterface  {
    currentTime: Date;
    setTime(d: Date) {
        <span style="color:Blue">this</span>.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
</pre>
</div>
<br>
Interfaces describe the public side of the class, rather than both the public and private side. This prohibits you from using them to check that a class also has particular types for the private side of the class instance.<br>
<h3>Difference between static/instance side of class</h3>
When working with classes and interfaces, it helps to keep in mind that a class has
<i>two</i> types: the type of the static side and the type of the instance side. You may notice that if you create an interface with a construct signature and try to create a class that implements this interface you get an error:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> ClockInterface {
    <span style="color:Blue">new</span> (hour: number, minute: number);
}

<span style="color:Blue">class</span> Clock <span style="color:Blue">implements</span> ClockInterface  {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
</pre>
</div>
<br>
This is because when a class implements an interface, only the instance side of the class is checked. Since the constructor sits in the static side, it is not included in this check.<br>
<br>
Instead, you would need to work with the &#39;static&#39; side of the class directly. In this example, we work with the class directly:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> ClockStatic {
    <span style="color:Blue">new</span> (hour: number, minute: number);
}

<span style="color:Blue">class</span> Clock  {
    currentTime: Date;
    constructor(h: number, m: number) { }
}

<span style="color:Blue">var</span> cs: ClockStatic = Clock;
<span style="color:Blue">var</span> newClock = <span style="color:Blue">new</span> cs(7, 30);
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="interfaces-extending-interfaces">Extending Interfaces</h2>
Like classes, interfaces can extend each other. This handles the task of copying the members of one interface into another, allowing you more freedom in how you separate your interfaces into reusable components.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> Shape {
    color: string;
}

<span style="color:Blue">interface</span> Square <span style="color:Blue">extends</span> Shape {
    sideLength: number;
}

<span style="color:Blue">var</span> square = &lt;Square&gt;{};
square.color = <span style="color:#A31515">&quot;blue&quot;</span>;
square.sideLength = 10;
</pre>
</div>
<br>
An interface can extend multiple interfaces, creating a combination of all of the interfaces.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> Shape {
    color: string;
}

<span style="color:Blue">interface</span> PenStroke {
    penWidth: number;
}

<span style="color:Blue">interface</span> Square <span style="color:Blue">extends</span> Shape, PenStroke {
    sideLength: number;
}

<span style="color:Blue">var</span> square = &lt;Square&gt;{};
square.color = <span style="color:#A31515">&quot;blue&quot;</span>;
square.sideLength = 10;
square.penWidth = 5.0;
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="interfaces-hybrid-types">Hybrid Types</h2>
As we mentioned earlier, interfaces can describe the rich types present in real world JavaScript. Because of JavaScript&#39;s dynamic and flexible nature, you may occasionally encounter an object that works as a combination of some of the types described above.
<br>
<br>
One such example is an object that acts as both a function and an object, with additional properties:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> Counter {
    (start: number): string;
    interval: number;
    reset(): <span style="color:Blue">void</span>;
}

<span style="color:Blue">var</span> c: Counter;
c(10);
c.reset();
c.interval = 5.0;
</pre>
</div>
<br>
When interacting with 3rd-party JavaScript, you may need to use patterns like the above to fully-describe the shape of the type.<br>
<hr>
<h1 class="has-hash-nav" data-hash-nav="classes">Classes</h1>
Traditional JavaScript focuses on functions and prototype-based inheritance as the basic means of building up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality
 and objects are built from these classes. Starting with ECMAScript 6, the next version of JavaScript, JavaScript programmers will be able to build their applications using this object-oriented class-based approach. In TypeScript, we allow developers to use
 these techniques now, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript.<br>
<h2 class="has-hash-nav" data-hash-nav="classes-classes">Classes</h2>
Let&#39;s take a look at a simple class-based example:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">class</span> Greeter {
    greeting: string;
    constructor(message: string) {
        <span style="color:Blue">this</span>.greeting = message;
    }
    greet() {
        <span style="color:Blue">return</span> <span style="color:#A31515">&quot;Hello, &quot;</span> &#43; <span style="color:Blue">this</span>.greeting;
    }
}

<span style="color:Blue">var</span> greeter = <span style="color:Blue">new</span> Greeter(<span style="color:#A31515">&quot;world&quot;</span>);
</pre>
</div>
<br>
The syntax should look very familiar if you&#39;ve used C# or Java before. We declare a new class &#39;Greeter&#39;. This class has three members, a property called &#39;greeting&#39;, a constructor, and a method &#39;greet&#39;.
<br>
<br>
You&#39;ll notice that in the class when we refer to one of the members of the class we prepend &#39;this.&#39;. This denotes that it&#39;s a member access.<br>
<br>
In the last line we construct an instance of the Greeter class using &#39;new&#39;. This calls into the constructor we defined earlier, creating a new object with the Greeter shape, and running the constructor to initialize it.<br>
<h2 class="has-hash-nav" data-hash-nav="classes-inheritance">Inheritance</h2>
In TypeScript, we can use common object-oriented patterns. Of course, one of the most fundamental patterns in class-based programming is being able to extend existing classes to create new ones using inheritance.<br>
<br>
Let&#39;s take a look at an example:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">class</span> Animal {
    name:string;
    constructor(theName: string) { <span style="color:Blue">this</span>.name = theName; }
    move(meters: number = 0) {
        alert(<span style="color:Blue">this</span>.name &#43; <span style="color:#A31515">&quot; moved &quot;</span> &#43; meters &#43; <span style="color:#A31515">&quot;m.&quot;</span>);
    }
}

<span style="color:Blue">class</span> Snake <span style="color:Blue">extends</span> Animal {
    constructor(name: string) { <span style="color:Blue">super</span>(name); }
    move(meters = 5) {
        alert(<span style="color:#A31515">&quot;Slithering...&quot;</span>);
        <span style="color:Blue">super</span>.move(meters);
    }
}

<span style="color:Blue">class</span> Horse <span style="color:Blue">extends</span> Animal {
    constructor(name: string) { <span style="color:Blue">super</span>(name); }
    move(meters = 45) {
        alert(<span style="color:#A31515">&quot;Galloping...&quot;</span>);
        <span style="color:Blue">super</span>.move(meters);
    }
}

<span style="color:Blue">var</span> sam = <span style="color:Blue">new</span> Snake(<span style="color:#A31515">&quot;Sammy the Python&quot;</span>);
<span style="color:Blue">var</span> tom: Animal = <span style="color:Blue">new</span> Horse(<span style="color:#A31515">&quot;Tommy the Palomino&quot;</span>);

sam.move();
tom.move(34);
</pre>
</div>
<br>
This example covers quite a bit of the inheritance features in TypeScript that are common to other languages. Here we see using the &#39;extends&#39; keywords to create a subclass. You can see this where &#39;Horse&#39; and &#39;Snake&#39; subclass the base
 class &#39;Animal&#39; and gain access to its features.<br>
<br>
The example also shows off being able to override methods in the base class with methods that are specialized for the subclass. Here both &#39;Snake&#39; and &#39;Horse&#39; create a &#39;move&#39; method that overrides the &#39;move&#39; from &#39;Animal&#39;,
 giving it functionality specific to each class.<br>
<h2 class="has-hash-nav" data-hash-nav="classes-privatepublic-modifiers">Private/Public modifiers</h2>
<h3>Public by default</h3>
You may have noticed in the above examples we haven&#39;t had to use the word &#39;public&#39; to make any of the members of the class visible. Languages like C# require that each member be explicitly labelled &#39;public&#39; to be visible. In TypeScript,
 each member is public by default. <br>
<br>
You may still mark members a private, so you control what is publicly visible outside of your class. We could have written the &#39;Animal&#39; class from the previous section like so:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">class</span> Animal {
    <span style="color:Blue">private</span> name:string;
    constructor(theName: string) { <span style="color:Blue">this</span>.name = theName; }
    move(meters: number) {
        alert(<span style="color:Blue">this</span>.name &#43; <span style="color:#A31515">&quot; moved &quot;</span> &#43; meters &#43; <span style="color:#A31515">&quot;m.&quot;</span>);
    }
}
</pre>
</div>
<h3>Understanding private</h3>
TypeScript is a structural type system. When we compare two different types, regardless of where they came from, if the types of each member are compatible, then we say the types themselves are compatible.
<br>
<br>
When comparing types that have &#39;private&#39; members, we treat these differently. For two types to be considered compatible, if one of them has a private member, then the other must have a private member that originated in the same declaration.
<br>
<br>
Let&#39;s look at an example to better see how this plays out in practice:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">class</span> Animal {
    <span style="color:Blue">private</span> name:string;
    constructor(theName: string) { <span style="color:Blue">this</span>.name = theName; }
}

<span style="color:Blue">class</span> Rhino <span style="color:Blue">extends</span> Animal {
	constructor() { <span style="color:Blue">super</span>(<span style="color:#A31515">&quot;Rhino&quot;</span>); }
}

<span style="color:Blue">class</span> Employee {
    <span style="color:Blue">private</span> name:string;
    constructor(theName: string) { <span style="color:Blue">this</span>.name = theName; }	
}

<span style="color:Blue">var</span> animal = <span style="color:Blue">new</span> Animal(<span style="color:#A31515">&quot;Goat&quot;</span>);
<span style="color:Blue">var</span> rhino = <span style="color:Blue">new</span> Rhino();
<span style="color:Blue">var</span> employee = <span style="color:Blue">new</span> Employee(<span style="color:#A31515">&quot;Bob&quot;</span>);

animal = rhino;
animal = employee; <span style="color:Green">//error: Animal and Employee are not compatible</span>
</pre>
</div>
<br>
In this example, we have an &#39;Animal&#39; and a &#39;Rhino&#39;, with &#39;Rhino&#39; being a subclass of &#39;Animal&#39;. We also have a new class &#39;Employee&#39; that looks identical to &#39;Animal&#39; in terms of shape. We create some instances of
 these classes and then try to assign them to each other to see what will happen. Because &#39;Animal&#39; and &#39;Rhino&#39; share the private side of their shape from the same declaration of &#39;private name: string&#39; in &#39;Animal&#39;, they are compatible.
 However, this is not the case for &#39;Employee&#39;. When we try to assign from an &#39;Employee&#39; to &#39;Animal&#39; we get an error that these types are not compatible. Even though &#39;Employee&#39; also has a private member called &#39;name&#39;,
 it is not the same one as the one created in &#39;Animal&#39;. <br>
<h3>Parameter properties</h3>
The keywords &#39;public&#39; and &#39;private&#39; also give you a shorthand for creating and initializing members of your class, by creating parameter properties. The properties let you can create and initialize a member in one step. Here&#39;s a further
 revision of the previous example. Notice how we drop &#39;theName&#39; altogether and just use the shortened &#39;private name: string&#39; parameter on the constructor to create and initialize the &#39;name&#39; member.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">class</span> Animal {
    constructor(<span style="color:Blue">private</span> name: string) { }
    move(meters: number) {
        alert(<span style="color:Blue">this</span>.name &#43; <span style="color:#A31515">&quot; moved &quot;</span> &#43; meters &#43; <span style="color:#A31515">&quot;m.&quot;</span>);
    }
}
</pre>
</div>
<br>
Using &#39;private&#39; in this way creates and initializes a private member, and similarly for &#39;public&#39;.
<br>
<h2 class="has-hash-nav" data-hash-nav="classes-accessors">Accessors</h2>
TypeScript supports getters/setters as a way of intercepting accesses to a member of an object. This gives you a way of having finer-grained control over how a member is accessed on each object.<br>
<br>
Let&#39;s convert a simple class to use &#39;get&#39; and &#39;set&#39;. First, let&#39;s start with an example without getters and setters.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">class</span> Employee {
    fullName: string;
}

<span style="color:Blue">var</span> employee = <span style="color:Blue">new</span> Employee();
employee.fullName = <span style="color:#A31515">&quot;Bob Smith&quot;</span>;
<span style="color:Blue">if</span> (employee.fullName) {
    alert(employee.fullName);
}
</pre>
</div>
<br>
While allowing people to randomly set fullName directly is pretty handy, this might get us in trouble if we people can change names on a whim.
<br>
<br>
In this version, we check to make sure the user has a secret passcode available before we allow them to modify the employee. We do this by replacing the direct access to fullName with a &#39;set&#39; that will check the passcode. We add a corresponding &#39;get&#39;
 to allow the previous example to continue to work seamlessly.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> passcode = <span style="color:#A31515">&quot;secret passcode&quot;</span>;

<span style="color:Blue">class</span> Employee {
    <span style="color:Blue">private</span> _fullName: string;

    get fullName(): string {
        <span style="color:Blue">return</span> <span style="color:Blue">this</span>._fullName;
    }
	
    set fullName(newName: string) {
        <span style="color:Blue">if</span> (passcode &amp;&amp; passcode == <span style="color:#A31515">&quot;secret passcode&quot;</span>) {
            <span style="color:Blue">this</span>._fullName = newName;
        }
        <span style="color:Blue">else</span> {
            alert(<span style="color:#A31515">&quot;Error: Unauthorized update of employee!&quot;</span>);
        }
    }
}

<span style="color:Blue">var</span> employee = <span style="color:Blue">new</span> Employee();
employee.fullName = <span style="color:#A31515">&quot;Bob Smith&quot;</span>;
<span style="color:Blue">if</span> (employee.fullName) {
    alert(employee.fullName);
}
</pre>
</div>
<br>
To prove to ourselves that our accessor is now checking the passcode, we can modify the passcode and see that when it doesn&#39;t match we instead get the alert box warning us we don&#39;t have access to update the employee.<br>
<br>
Note: Accessors require you to set the compiler to output ECMAScript 5.<br>
<h2 class="has-hash-nav" data-hash-nav="classes-static-properties">Static Properties</h2>
Up to this point, we&#39;ve only talked about the <i>instance</i> members of the class, those that show up on the object when its instantiated. We can also create
<i>static</i> members of a class, those that are visible on the class itself rather than on the instances. In this example, we use &#39;static&#39; on the origin, as it&#39;s a general value for all grids. Each instance accesses this value through prepending
 the name of the class. Similarly to prepending &#39;this.&#39; in front of instance accesses, here we prepend &#39;Grid.&#39; in front of static accesses.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">class</span> Grid {
    <span style="color:Blue">static</span> origin = {x: 0, y: 0};
    calculateDistanceFromOrigin(point: {x: number; y: number;}) {
        <span style="color:Blue">var</span> xDist = (point.x - Grid.origin.x);
        <span style="color:Blue">var</span> yDist = (point.y - Grid.origin.y);
        <span style="color:Blue">return</span> Math.sqrt(xDist * xDist &#43; yDist * yDist) / <span style="color:Blue">this</span>.scale;
    }
    constructor (<span style="color:Blue">public</span> scale: number) { }
}

<span style="color:Blue">var</span> grid1 = <span style="color:Blue">new</span> Grid(1.0);  <span style="color:Green">// 1x scale</span>
<span style="color:Blue">var</span> grid2 = <span style="color:Blue">new</span> Grid(5.0);  <span style="color:Green">// 5x scale</span>

alert(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));
alert(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="classes-advanced-techniques">Advanced Techniques</h2>
<h3>Constructor functions</h3>
When you declare a class in TypeScript, you are actually creating multiple declarations at the same time. The first is the type of the
<i>instance</i> of the class.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">class</span> Greeter {
    greeting: string;
    constructor(message: string) {
        <span style="color:Blue">this</span>.greeting = message;
    }
    greet() {
        <span style="color:Blue">return</span> <span style="color:#A31515">&quot;Hello, &quot;</span> &#43; <span style="color:Blue">this</span>.greeting;
    }
}

<span style="color:Blue">var</span> greeter: Greeter;
greeter = <span style="color:Blue">new</span> Greeter(<span style="color:#A31515">&quot;world&quot;</span>);
alert(greeter.greet());
</pre>
</div>
<br>
Here, when we say &#39;var greeter: Greeter&#39;, we&#39;re using Greeter as the type of instances of the class Greeter. This is almost second nature to programmers from other object-oriented languages.
<br>
<br>
We&#39;re also creating another value that we call the <i>constructor function</i>. This is the function that is called when we &#39;new&#39; up instances of the class. To see what this looks like in practice, let&#39;s take a look at the JavaScript created
 by the above example:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> Greeter = (<span style="color:Blue">function</span> () {
    <span style="color:Blue">function</span> Greeter(message) {
        <span style="color:Blue">this</span>.greeting = message;
    }
    Greeter.prototype.greet = <span style="color:Blue">function</span> () {
        <span style="color:Blue">return</span> <span style="color:#A31515">&quot;Hello, &quot;</span> &#43; <span style="color:Blue">this</span>.greeting;
    };
    <span style="color:Blue">return</span> Greeter;
})();

<span style="color:Blue">var</span> greeter;
greeter = <span style="color:Blue">new</span> Greeter(<span style="color:#A31515">&quot;world&quot;</span>);
alert(greeter.greet());
</pre>
</div>
<br>
Here, &#39;var Greeter&#39; is going to be assigned the constructor function. When we call &#39;new&#39; and run this function, we get an instance of the class. The constructor function also contains all of the static members of the class. Another way to think
 of each class is that there is an <i>instance</i> side and a <i>static</i> side.<br>
<br>
Let&#39;s modify the example a bit to show this difference:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">class</span> Greeter {
    <span style="color:Blue">static</span> standardGreeting = <span style="color:#A31515">&quot;Hello, there&quot;</span>;
    greeting: string;
    greet() {
        <span style="color:Blue">if</span> (<span style="color:Blue">this</span>.greeting) {
            <span style="color:Blue">return</span> <span style="color:#A31515">&quot;Hello, &quot;</span> &#43; <span style="color:Blue">this</span>.greeting;
        }
        <span style="color:Blue">else</span> {
            <span style="color:Blue">return</span> Greeter.standardGreeting;
        }
    }
}

<span style="color:Blue">var</span> greeter1: Greeter;
greeter1 = <span style="color:Blue">new</span> Greeter();
alert(greeter1.greet());

<span style="color:Blue">var</span> greeterMaker: <span style="color:Blue">typeof</span> Greeter = Greeter;
greeterMaker.standardGreeting = <span style="color:#A31515">&quot;Hey there!&quot;</span>;
<span style="color:Blue">var</span> greeter2:Greeter = <span style="color:Blue">new</span> greeterMaker();
alert(greeter2.greet());
</pre>
</div>
<br>
In this example, &#39;greeter1&#39; works similarly to before. We instantiate the &#39;Greeter&#39; class, and use this object. This we have seen before.<br>
<br>
Next, we then use the class directly. Here we create a new variable called &#39;greeterMaker&#39;. This variable will hold the class itself, or said another way its constructor function. Here we use &#39;typeof Greeter&#39;, that is &quot;give me the type of
 the Greeter class itself&quot; rather than the instance type. Or, more precisely, &quot;give me the type of the symbol called Greeter&quot;, which is the type of the constructor function. This type will contain all of the static members of Greeter along with
 the constructor that creates instances of the Greeter class. We show this by using &#39;new&#39; on &#39;greeterMaker&#39;, creating new instances of &#39;Greeter&#39; and invoking them as before.<br>
<h3>Using a class as an interface</h3>
As we said in the previous section, a class declaration creates two things: a type representing instances of the class and a constructor function. Because classes create types, you can use them in the same places you would be able to use interfaces.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">class</span> Point {
    x: number;
    y: number;
}

<span style="color:Blue">interface</span> Point3d <span style="color:Blue">extends</span> Point {
    z: number;
}

<span style="color:Blue">var</span> point3d: Point3d = {x: 1, y: 2, z: 3};
</pre>
</div>
<br>
<br>
<hr>
<h1 class="has-hash-nav" data-hash-nav="modules">Modules</h1>
This post outlines the various ways to organize your code using modules in TypeScript. We&#39;ll be covering internal and external modules and we&#39;ll discuss when each is appropriate and how to use them. We&#39;ll also go over some advanced topics of how
 to use external modules, and address some common pitfalls when using modules in TypeScript.<br>
<h4>First steps</h4>
Let&#39;s start with the program we&#39;ll be using as our example throughout this page. We&#39;ve written a small set of simplistic string validators, like you might use when checking a user&#39;s input on a form in a webpage or checking the format of an externally-provided
 data file.<br>
<h6>Validators in a single file</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> StringValidator {
    isAcceptable(s: string): <span style="color:Blue">boolean</span>;
}

<span style="color:Blue">var</span> lettersRegexp = /^[A-Za-z]&#43;$/;
<span style="color:Blue">var</span> numberRegexp = /^[0-9]&#43;$/;

<span style="color:Blue">class</span> LettersOnlyValidator <span style="color:Blue">implements</span> StringValidator {
    isAcceptable(s: string) {
        <span style="color:Blue">return</span> lettersRegexp.test(s);
    }
}

<span style="color:Blue">class</span> ZipCodeValidator <span style="color:Blue">implements</span> StringValidator {
    isAcceptable(s: string) {
        <span style="color:Blue">return</span> s.length === 5 &amp;&amp; numberRegexp.test(s);
    }
}

<span style="color:Green">// Some samples to try</span>
<span style="color:Blue">var</span> strings = [<span style="color:#A31515">&#39;Hello&#39;</span>, <span style="color:#A31515">&#39;98052&#39;</span>, <span style="color:#A31515">&#39;101&#39;</span>];
<span style="color:Green">// Validators to use</span>
<span style="color:Blue">var</span> validators: { [s: string]: StringValidator; } = {};
validators[<span style="color:#A31515">&#39;ZIP code&#39;</span>] = <span style="color:Blue">new</span> ZipCodeValidator();
validators[<span style="color:#A31515">&#39;Letters only&#39;</span>] = <span style="color:Blue">new</span> LettersOnlyValidator();
<span style="color:Green">// Show whether each string passed each validator</span>
strings.forEach(s =&gt; {
    <span style="color:Blue">for</span> (<span style="color:Blue">var</span> name <span style="color:Blue">in</span> validators) {
        console.log(<span style="color:#A31515">&#39;&quot;&#39;</span> &#43; s &#43; <span style="color:#A31515">&#39;&quot; &#39;</span> &#43; (validators[name].isAcceptable(s) ? <span style="color:#A31515">&#39; matches &#39;</span> : <span style="color:#A31515">&#39; does not match &#39;</span>) &#43; name);
    }
});
</pre>
</div>
<h4>Adding Modularity</h4>
As we add more validators, we&#39;re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects. Instead of putting lots of different names into the global namespace,
 let&#39;s wrap up our objects into a module.<br>
<br>
In this example, we&#39;ve moved all the Validator-related types into a module called
<i>Validation</i>. Because we want the interfaces and classes here to be visible outside the module, we preface them with
<i>export</i>. Conversely, the variables <i>lettersRegexp</i> and <i>numberRegexp</i> are implementation details, so they are left unexported and will not be visible to code outside the module. In the test code at the bottom of the file, we now need to qualify
 the names of the types when used outside the module, e.g. <i>Validation.LettersOnlyValidator</i>.<br>
<h6>Modularized Validators</h6>
<div style="color:Black; background-color:White">
<pre>
module Validation {
    <span style="color:Blue">export</span> <span style="color:Blue">interface</span> StringValidator {
        isAcceptable(s: string): <span style="color:Blue">boolean</span>;
    }

    <span style="color:Blue">var</span> lettersRegexp = /^[A-Za-z]&#43;$/;
    <span style="color:Blue">var</span> numberRegexp = /^[0-9]&#43;$/;

    <span style="color:Blue">export</span> <span style="color:Blue">class</span> LettersOnlyValidator <span style="color:Blue">implements</span> StringValidator {
        isAcceptable(s: string) {
            <span style="color:Blue">return</span> lettersRegexp.test(s);
        }
    }

    <span style="color:Blue">export</span> <span style="color:Blue">class</span> ZipCodeValidator <span style="color:Blue">implements</span> StringValidator {
        isAcceptable(s: string) {
            <span style="color:Blue">return</span> s.length === 5 &amp;&amp; numberRegexp.test(s);
        }
    }
}

<span style="color:Green">// Some samples to try</span>
<span style="color:Blue">var</span> strings = [<span style="color:#A31515">&#39;Hello&#39;</span>, <span style="color:#A31515">&#39;98052&#39;</span>, <span style="color:#A31515">&#39;101&#39;</span>];
<span style="color:Green">// Validators to use</span>
<span style="color:Blue">var</span> validators: { [s: string]: Validation.StringValidator; } = {};
validators[<span style="color:#A31515">&#39;ZIP code&#39;</span>] = <span style="color:Blue">new</span> Validation.ZipCodeValidator();
validators[<span style="color:#A31515">&#39;Letters only&#39;</span>] = <span style="color:Blue">new</span> Validation.LettersOnlyValidator();
<span style="color:Green">// Show whether each string passed each validator</span>
strings.forEach(s =&gt; {
    <span style="color:Blue">for</span> (<span style="color:Blue">var</span> name <span style="color:Blue">in</span> validators) {
        console.log(<span style="color:#A31515">&#39;&quot;&#39;</span> &#43; s &#43; <span style="color:#A31515">&#39;&quot; &#39;</span> &#43; (validators[name].isAcceptable(s) ? <span style="color:#A31515">&#39; matches &#39;</span> : <span style="color:#A31515">&#39; does not match &#39;</span>) &#43; name);
    }
});
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="modules-splitting-across-files">Splitting Across Files</h2>
As our application grows, we&#39;ll want to split the code across multiple files to make it easier to maintain.<br>
<br>
Here, we&#39;ve split our Validation module across many files. Even though the files are separate, they can each contribute to the same module and can be consumed as if they were all defined in one place. Because there are dependencies between files, we&#39;ve
 added reference tags to tell the compiler about the relationships between the files. Our test code is otherwise unchanged.<br>
<h4>Multi-file internal modules</h4>
<h6>Validation.ts</h6>
<div style="color:Black; background-color:White">
<pre>
module Validation {
    <span style="color:Blue">export</span> <span style="color:Blue">interface</span> StringValidator {
        isAcceptable(s: string): <span style="color:Blue">boolean</span>;
    }
}
</pre>
</div>
<h6>LettersOnlyValidator.ts</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Green">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span>
module Validation {
    <span style="color:Blue">var</span> lettersRegexp = /^[A-Za-z]&#43;$/;
    <span style="color:Blue">export</span> <span style="color:Blue">class</span> LettersOnlyValidator <span style="color:Blue">implements</span> StringValidator {
        isAcceptable(s: string) {
            <span style="color:Blue">return</span> lettersRegexp.test(s);
        }
    }
}
</pre>
</div>
<h6>ZipCodeValidator.ts</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Green">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span>
module Validation {
    <span style="color:Blue">var</span> numberRegexp = /^[0-9]&#43;$/;
    <span style="color:Blue">export</span> <span style="color:Blue">class</span> ZipCodeValidator <span style="color:Blue">implements</span> StringValidator {
        isAcceptable(s: string) {
            <span style="color:Blue">return</span> s.length === 5 &amp;&amp; numberRegexp.test(s);
        }
    }
}
</pre>
</div>
<h6>Test.ts</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Green">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span>
<span style="color:Green">/// &lt;reference path=&quot;LettersOnlyValidator.ts&quot; /&gt;</span>
<span style="color:Green">/// &lt;reference path=&quot;ZipCodeValidator.ts&quot; /&gt;</span>

<span style="color:Green">// Some samples to try</span>
<span style="color:Blue">var</span> strings = [<span style="color:#A31515">&#39;Hello&#39;</span>, <span style="color:#A31515">&#39;98052&#39;</span>, <span style="color:#A31515">&#39;101&#39;</span>];
<span style="color:Green">// Validators to use</span>
<span style="color:Blue">var</span> validators: { [s: string]: Validation.StringValidator; } = {};
validators[<span style="color:#A31515">&#39;ZIP code&#39;</span>] = <span style="color:Blue">new</span> Validation.ZipCodeValidator();
validators[<span style="color:#A31515">&#39;Letters only&#39;</span>] = <span style="color:Blue">new</span> Validation.LettersOnlyValidator();
<span style="color:Green">// Show whether each string passed each validator</span>
strings.forEach(s =&gt; {
    <span style="color:Blue">for</span> (<span style="color:Blue">var</span> name <span style="color:Blue">in</span> validators) {
        console.log(<span style="color:#A31515">&#39;&quot;&#39;</span> &#43; s &#43; <span style="color:#A31515">&#39;&quot; &#39;</span> &#43; (validators[name].isAcceptable(s) ? <span style="color:#A31515">&#39; matches &#39;</span> : <span style="color:#A31515">&#39; does not match &#39;</span>) &#43; name);
    }
});
</pre>
</div>
<br>
Once there are multiple files involved, we&#39;ll need to make sure all of the compiled code gets loaded. There are two ways of doing this.<br>
<br>
First, we can use concatenated output using the <i>--out</i> flag to compile all of the input files into a single JavaScript output file:<br>
<pre>
tsc --out sample.js Test.ts
</pre>
<br>
The compiler will automatically order the output file based on the reference tags present in the files. You can also specify each file individually:<br>
<pre>
tsc --out sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts
</pre>
<br>
<br>
Alternatively, we can use per-file compilation (the default) to emit one JavaScript file for each input file. If multiple JS files get produced, we&#39;ll need to use
<i>&lt;script&gt;</i> tags on our webpage to load each emitted file in the appropriate order, for example:<br>
<h6>MyTestPage.html (excerpt)</h6>
<div style="color:Black; background-color:White">
<pre>
    <span style="color:Blue">&lt;</span><span style="color:#A31515">script</span> <span style="color:Red">src</span><span style="color:Blue">=</span><span style="color:Blue">&quot;Validation.js&quot;</span> <span style="color:Red">type</span><span style="color:Blue">=</span><span style="color:Blue">&quot;text/javascript&quot;</span> <span style="color:Blue">/&gt;</span>
    <span style="color:Blue">&lt;</span><span style="color:#A31515">script</span> <span style="color:Red">src</span><span style="color:Blue">=</span><span style="color:Blue">&quot;LettersOnlyValidator.js&quot;</span> <span style="color:Red">type</span><span style="color:Blue">=</span><span style="color:Blue">&quot;text/javascript&quot;</span> <span style="color:Blue">/&gt;</span>
    <span style="color:Blue">&lt;</span><span style="color:#A31515">script</span> <span style="color:Red">src</span><span style="color:Blue">=</span><span style="color:Blue">&quot;ZipCodeValidator.js&quot;</span> <span style="color:Red">type</span><span style="color:Blue">=</span><span style="color:Blue">&quot;text/javascript&quot;</span> <span style="color:Blue">/&gt;</span>
    <span style="color:Blue">&lt;</span><span style="color:#A31515">script</span> <span style="color:Red">src</span><span style="color:Blue">=</span><span style="color:Blue">&quot;Test.js&quot;</span> <span style="color:Red">type</span><span style="color:Blue">=</span><span style="color:Blue">&quot;text/javascript&quot;</span> <span style="color:Blue">/&gt;</span>
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="modules-going-external">Going External</h2>
TypeScript also has the concept of an external module. External modules are used in two cases: node.js and require.js. Applications not using node.js or require.js do not need to use external modules and can best be organized using the internal module concept
 outlined above.<br>
<br>
In external modules, relationships between files are specified in terms of imports and exports at the file level. In TypeScript, any file containing a top-level
<i>import</i> or <i>export</i> is considered an external module.<br>
<br>
Below, we have converted the previous example to use external modules. Notice that we no longer use the module keyword  the files themselves constitute a module and are identified by their filenames.<br>
<br>
The reference tags have been replaced with <i>import</i> statements that specify the dependencies between modules. The
<i>import</i> statement has two parts: the name that the module will be known by in this file, and the require keyword that specifies the path to the required module:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">import</span> someMod = require(<span style="color:#A31515">&#39;someModule&#39;</span>);
</pre>
</div>
<br>
We specify which objects are visible outside the module by using the <i>export</i> keyword on a top-level declaration, similarly to how
<i>export</i> defined the public surface area of an internal module.<br>
<br>
To compile, we must specify a module target on the command line. For node.js, use
<i>--module commonjs</i>; for require.js, use <i>--module amd</i>. For example:<br>
<pre>
tsc --module commonjs Test.ts
</pre>
<br>
When compiled, each external module will become a separate .js file. Similar to reference tags, the compiler will follow
<i>import</i> statements to compile dependent files.<br>
<h6>Validation.ts</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">export</span> <span style="color:Blue">interface</span> StringValidator {
    isAcceptable(s: string): <span style="color:Blue">boolean</span>;
}
</pre>
</div>
<h6>LettersOnlyValidator.ts</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">import</span> validation = require(<span style="color:#A31515">&#39;./Validation&#39;</span>);
<span style="color:Blue">var</span> lettersRegexp = /^[A-Za-z]&#43;$/;
<span style="color:Blue">export</span> <span style="color:Blue">class</span> LettersOnlyValidator <span style="color:Blue">implements</span> validation.StringValidator {
    isAcceptable(s: string) {
        <span style="color:Blue">return</span> lettersRegexp.test(s);
    }
}
</pre>
</div>
<h6>ZipCodeValidator.ts</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">import</span> validation = require(<span style="color:#A31515">&#39;./Validation&#39;</span>);
<span style="color:Blue">var</span> numberRegexp = /^[0-9]&#43;$/;
<span style="color:Blue">export</span> <span style="color:Blue">class</span> ZipCodeValidator <span style="color:Blue">implements</span> validation.StringValidator {
    isAcceptable(s: string) {
        <span style="color:Blue">return</span> s.length === 5 &amp;&amp; numberRegexp.test(s);
    }
}
</pre>
</div>
<h6>Test.ts</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">import</span> validation = require(<span style="color:#A31515">&#39;./Validation&#39;</span>);
<span style="color:Blue">import</span> zip = require(<span style="color:#A31515">&#39;./ZipCodeValidator&#39;</span>);
<span style="color:Blue">import</span> letters = require(<span style="color:#A31515">&#39;./LettersOnlyValidator&#39;</span>);

<span style="color:Green">// Some samples to try</span>
<span style="color:Blue">var</span> strings = [<span style="color:#A31515">&#39;Hello&#39;</span>, <span style="color:#A31515">&#39;98052&#39;</span>, <span style="color:#A31515">&#39;101&#39;</span>];
<span style="color:Green">// Validators to use</span>
<span style="color:Blue">var</span> validators: { [s: string]: validation.StringValidator; } = {};
validators[<span style="color:#A31515">&#39;ZIP code&#39;</span>] = <span style="color:Blue">new</span> zip.ZipCodeValidator();
validators[<span style="color:#A31515">&#39;Letters only&#39;</span>] = <span style="color:Blue">new</span> letters.LettersOnlyValidator();
<span style="color:Green">// Show whether each string passed each validator</span>
strings.forEach(s =&gt; {
    <span style="color:Blue">for</span> (<span style="color:Blue">var</span> name <span style="color:Blue">in</span> validators) {
        console.log(<span style="color:#A31515">&#39;&quot;&#39;</span> &#43; s &#43; <span style="color:#A31515">&#39;&quot; &#39;</span> &#43; (validators[name].isAcceptable(s) ? <span style="color:#A31515">&#39; matches &#39;</span> : <span style="color:#A31515">&#39; does not match &#39;</span>) &#43; name);
    }
});
</pre>
</div>
<h4>Code Generation for External Modules</h4>
Depending on the module target specified during compilation, the compiler will generate appropriate code for either node.js (commonjs) or require.js (AMD) module-loading systems. For more information on what the
<i>define</i> and <i>require</i> calls in the generated code do, consult the documentation for each module loader.<br>
<br>
This simple example shows how the names used during importing and exporting get translated into the module loading code.<br>
<h6>SimpleModule.ts</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">import</span> m = require(<span style="color:#A31515">&#39;mod&#39;</span>);
<span style="color:Blue">export</span> <span style="color:Blue">var</span> t = m.something &#43; 1;
</pre>
</div>
<h6>AMD / RequireJS SimpleModule.js:</h6>
<div style="color:Black; background-color:White">
<pre>
define([<span style="color:#A31515">&quot;require&quot;</span>, <span style="color:#A31515">&quot;exports&quot;</span>, <span style="color:#A31515">&#39;mod&#39;</span>], <span style="color:Blue">function</span>(require, exports, m) {
    exports.t = m.something &#43; 1;
});
</pre>
</div>
<h6>CommonJS / Node SimpleModule.js:</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> m = require(<span style="color:#A31515">&#39;mod&#39;</span>);
exports.t = m.something &#43; 1;
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="modules-export-">Export =</h2>
In the previous example, when we consumed each validator, each module only exported one value. In cases like this, it&#39;s cumbersome to work with these symbols through their qualified name when a single identifier would do just as well.<br>
<br>
The export = syntax specifies a single object that is exported from the module. This can be a class, interface, module, function, or enum. When imported, the exported symbol is consumed directly and is not qualified by any name.<br>
<br>
Below, we&#39;ve simplified the Validator implementations to only export a single object from each module using the export = syntax. This simplifies the consumption code  instead of referring to &#39;zip.ZipCodeValidator&#39;, we can simply refer to &#39;zipValidator&#39;.<br>
<h6>Validation.ts</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">export</span> <span style="color:Blue">interface</span> StringValidator {
    isAcceptable(s: string): <span style="color:Blue">boolean</span>;
}
</pre>
</div>
<h6>LettersOnlyValidator.ts</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">import</span> validation = require(<span style="color:#A31515">&#39;./Validation&#39;</span>);
<span style="color:Blue">var</span> lettersRegexp = /^[A-Za-z]&#43;$/;
<span style="color:Blue">class</span> LettersOnlyValidator <span style="color:Blue">implements</span> validation.StringValidator {
    isAcceptable(s: string) {
        <span style="color:Blue">return</span> lettersRegexp.test(s);
    }
}
<span style="color:Blue">export</span> = LettersOnlyValidator;
</pre>
</div>
<h6>ZipCodeValidator.ts</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">import</span> validation = require(<span style="color:#A31515">&#39;./Validation&#39;</span>);
<span style="color:Blue">var</span> numberRegexp = /^[0-9]&#43;$/;
<span style="color:Blue">class</span> ZipCodeValidator <span style="color:Blue">implements</span> validation.StringValidator {
    isAcceptable(s: string) {
        <span style="color:Blue">return</span> s.length === 5 &amp;&amp; numberRegexp.test(s);
    }
}
<span style="color:Blue">export</span> = ZipCodeValidator;
</pre>
</div>
<h6>Test.ts</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">import</span> validation = require(<span style="color:#A31515">&#39;./Validation&#39;</span>);
<span style="color:Blue">import</span> zipValidator = require(<span style="color:#A31515">&#39;./ZipCodeValidator&#39;</span>);
<span style="color:Blue">import</span> lettersValidator = require(<span style="color:#A31515">&#39;./LettersOnlyValidator&#39;</span>);

<span style="color:Green">// Some samples to try</span>
<span style="color:Blue">var</span> strings = [<span style="color:#A31515">&#39;Hello&#39;</span>, <span style="color:#A31515">&#39;98052&#39;</span>, <span style="color:#A31515">&#39;101&#39;</span>];
<span style="color:Green">// Validators to use</span>
<span style="color:Blue">var</span> validators: { [s: string]: validation.StringValidator; } = {};
validators[<span style="color:#A31515">&#39;ZIP code&#39;</span>] = <span style="color:Blue">new</span> zipValidator();
validators[<span style="color:#A31515">&#39;Letters only&#39;</span>] = <span style="color:Blue">new</span> lettersValidator();
<span style="color:Green">// Show whether each string passed each validator</span>
strings.forEach(s =&gt; {
    <span style="color:Blue">for</span> (<span style="color:Blue">var</span> name <span style="color:Blue">in</span> validators) {
        console.log(<span style="color:#A31515">&#39;&quot;&#39;</span> &#43; s &#43; <span style="color:#A31515">&#39;&quot; &#39;</span> &#43; (validators[name].isAcceptable(s) ? <span style="color:#A31515">&#39; matches &#39;</span> : <span style="color:#A31515">&#39; does not match &#39;</span>) &#43; name);
    }
});
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="modules-alias">Alias</h2>
Another way that you can simplify working with either kind of module is to use <i>
import q = x.y.z</i> to create shorter names for commonly-used objects. Not to be confused with the
<i>import x = require(&#39;name&#39;)</i> syntax used to load external modules, this syntax simply creates an alias for the specified symbol. You can use these sorts of imports (commonly referred to as aliases) for any kind of identifier, including objects
 created from external module imports.<br>
<h6>Basic Aliasing</h6>
<div style="color:Black; background-color:White">
<pre>
module Shapes {
    <span style="color:Blue">export</span> module Polygons {
        <span style="color:Blue">export</span> <span style="color:Blue">class</span> Triangle { }
        <span style="color:Blue">export</span> <span style="color:Blue">class</span> Square { }
    }
}

<span style="color:Blue">import</span> polygons = Shapes.Polygons;
<span style="color:Blue">var</span> sq = <span style="color:Blue">new</span> polygons.Square(); <span style="color:Green">// Same as &#39;new Shapes.Polygons.Square()&#39;</span>
</pre>
</div>
<br>
Notice that we don&#39;t use the <i>require</i> keyword; instead we assign directly from the qualified name of the symbol we&#39;re importing. This is similar to using
<i>var</i>, but also works on the type and namespace meanings of the imported symbol. Importantly, for values,
<i>import</i> is a distinct reference from the original symbol, so changes to an aliased
<i>var</i> will not be reflected in the original variable.<br>
<h2 class="has-hash-nav" data-hash-nav="modules-optional-module-loading-and-other-advanced-loading-scenarios">Optional Module Loading and Other Advanced Loading Scenarios</h2>
In some cases, you may want to only load a module under some conditions. In TypeScript, we can use the pattern shown below to implement this and other advanced loading scenarios to directly invoke the module loaders without losing type safety.<br>
<br>
The compiler detects whether each module is used in the emitted JavaScript. For modules that are only used as part of the type system, no require calls are emitted. This culling of unused references is a good performance optimization, and also allows for optional
 loading of those modules.<br>
<br>
The core idea of the pattern is that the <i>import id = require(&#39;...&#39;)</i> statement gives us access to the types exposed by the external module. The module loader is invoked (through require) dynamically, as shown in the if blocks below. This leverages
 the reference-culling optimization so that the module is only loaded when needed. For this pattern to work, it&#39;s important that the symbol defined via import is only used in type positions (i.e. never in a position that would be emitted into the JavaScript).<br>
<br>
To maintain type safety, we can use the <i>typeof</i> keyword. The <i>typeof</i> keyword, when used in a type position, produces the type of a value, in this case the type of the external module.<br>
<h6>Dynamic Module Loading in node.js</h6>
<div style="color:Black; background-color:White">
<pre>
declare <span style="color:Blue">var</span> require;
<span style="color:Blue">import</span> Zip = require(<span style="color:#A31515">&#39;./ZipCodeValidator&#39;</span>);
<span style="color:Blue">if</span> (needZipValidation) {
    <span style="color:Blue">var</span> x: <span style="color:Blue">typeof</span> Zip = require(<span style="color:#A31515">&#39;./ZipCodeValidator&#39;</span>);
    <span style="color:Blue">if</span> (x.isAcceptable(<span style="color:#A31515">&#39;.....&#39;</span>)) { <span style="color:Green">/* ... */</span> }
}
</pre>
</div>
<h6>Sample: Dynamic Module Loading in require.js</h6>
<div style="color:Black; background-color:White">
<pre>
declare <span style="color:Blue">var</span> require;
<span style="color:Blue">import</span> Zip = require(<span style="color:#A31515">&#39;./ZipCodeValidator&#39;</span>);
<span style="color:Blue">if</span> (needZipValidation) {
    require([<span style="color:#A31515">&#39;./ZipCodeValidator&#39;</span>], (x: <span style="color:Blue">typeof</span> Zip) =&gt; {
        <span style="color:Blue">if</span> (x.isAcceptable(<span style="color:#A31515">&#39;...&#39;</span>)) { <span style="color:Green">/* ... */</span> }
    });
}
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="modules-working-with-other-javascript-libraries">Working with Other JavaScript Libraries</h2>
To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes. Because most JavaScript libraries expose only a few top-level objects, modules are a good way to represent them. We call declarations that don&#39;t
 define an implementation &quot;ambient&quot;. Typically these are defined in .d.ts files. If you&#39;re familiar with C/C&#43;&#43;, you can think of these as .h files or &#39;extern&#39;. Let&#39;s look at a few examples with both internal and external examples.<br>
<h4>Ambient Internal Modules</h4>
The popular library D3 defines its functionality in a global object called &#39;D3&#39;. Because this library is loaded through a
<i>script</i> tag (instead of a module loader), its declaration uses internal modules to define its shape. For the TypeScript compiler to see this shape, we use an ambient internal module declaration. For example:<br>
<h6>D3.d.ts (simplified excerpt)</h6>
<div style="color:Black; background-color:White">
<pre>
declare module D3 {
    <span style="color:Blue">export</span> <span style="color:Blue">interface</span> Selectors {
        select: {
            (selector: string): Selection;
            (element: EventTarget): Selection;
        };
    }

    <span style="color:Blue">export</span> <span style="color:Blue">interface</span> Event {
        x: number;
        y: number;
    }

    <span style="color:Blue">export</span> <span style="color:Blue">interface</span> Base <span style="color:Blue">extends</span> Selectors {
        event: Event;
    }
}

declare <span style="color:Blue">var</span> d3: D3.Base;
</pre>
</div>
<h4>Ambient External Modules</h4>
In node.js, most tasks are accomplished by loading one or more modules. We could define each module in its own .d.ts file with top-level export declarations, but it&#39;s more convenient to write them as one larger .d.ts file. To do so, we use the quoted name
 of the module, which will be available to a later import. For example:<br>
<h6>node.d.ts (simplified excerpt)</h6>
<div style="color:Black; background-color:White">
<pre>
declare module <span style="color:#A31515">&quot;url&quot;</span> {
    <span style="color:Blue">export</span> <span style="color:Blue">interface</span> Url {
        protocol?: string;
        hostname?: string;
        pathname?: string;
    }

    <span style="color:Blue">export</span> <span style="color:Blue">function</span> parse(urlStr: string, parseQueryString?, slashesDenoteHost?): Url;
}

declare module <span style="color:#A31515">&quot;path&quot;</span> {
    <span style="color:Blue">export</span> <span style="color:Blue">function</span> normalize(p: string): string;
    <span style="color:Blue">export</span> <span style="color:Blue">function</span> join(...paths: any[]): string;
    <span style="color:Blue">export</span> <span style="color:Blue">var</span> sep: string;
}
</pre>
</div>
<br>
Now we can <i>/// &lt;reference&gt;</i> node.d.ts and then load the modules using e.g.
<i>import url = require(&#39;url&#39;);</i>.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Green">///&lt;reference path=&quot;node.d.ts&quot;/&gt;</span>
<span style="color:Blue">import</span> url = require(<span style="color:#A31515">&quot;url&quot;</span>);
<span style="color:Blue">var</span> myUrl = url.parse(<span style="color:#A31515">&quot;http://www.typescriptlang.org&quot;</span>);
</pre>
</div>
<br>
<h2 class="has-hash-nav" data-hash-nav="modules-pitfalls-of-modules">Pitfalls of Modules</h2>
In this section we&#39;ll describe various common pitfalls in using internal and external modules, and how to avoid them.<br>
<h4>/// &lt;reference&gt; to an external module</h4>
A common mistake is to try to use the /// &lt;reference&gt; syntax to refer to an external module file, rather than using import. To understand the distinction, we first need to understand the three ways that the compiler can locate the type information for
 an external module.<br>
<br>
The first is by finding a .ts file named by an <i>import x = require(...);</i> declaration. That file should be an implementation file with top-level import or export declarations.<br>
<br>
The second is by finding a .d.ts file, similar to above, except that instead of being an implementation file, it&#39;s a declaration file (also with top-level import or export declarations).<br>
<br>
The final way is by seeing an &quot;ambient external module declaration&quot;, where we &#39;declare&#39; a module with a matching quoted name.<br>
<h6>myModules.d.ts</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Green">// In a .d.ts file or .ts file that is not an external module:</span>
declare module <span style="color:#A31515">&quot;SomeModule&quot;</span> {
    <span style="color:Blue">export</span> <span style="color:Blue">function</span> fn(): string;
}
</pre>
</div>
<h6>myOtherModule.ts</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Green">/// &lt;reference path=&quot;myModules.d.ts&quot; /&gt;</span>
<span style="color:Blue">import</span> m = require(<span style="color:#A31515">&quot;SomeModule&quot;</span>);
</pre>
</div>
<br>
The reference tag here allows us to locate the declaration file that contains the declaration for the ambient external module. This is how the node.d.ts file that several of the TypeScript samples use is consumed, for example.<br>
<h4>Needless Namespacing</h4>
If you&#39;re converting a program from internal modules to external modules, it can be easy to end up with a file that looks like this:<br>
<h6>shapes.ts</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">export</span> module Shapes {
    <span style="color:Blue">export</span> <span style="color:Blue">class</span> Triangle { <span style="color:Green">/* ... */</span> }
    <span style="color:Blue">export</span> <span style="color:Blue">class</span> Square { <span style="color:Green">/* ... */</span> }
}
</pre>
</div>
<br>
The top-level module here <i>Shapes</i> wraps up <i>Triangle</i> and <i>Square</i> for no reason. This is confusing and annoying for consumers of your module:
<h6>shapeConsumer.ts</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">import</span> shapes = require(<span style="color:#A31515">&#39;./shapes&#39;</span>);
<span style="color:Blue">var</span> t = <span style="color:Blue">new</span> shapes.Shapes.Triangle(); <span style="color:Green">// shapes.Shapes?</span>
</pre>
</div>
<br>
A key feature of external modules in TypeScript is that two different external modules will never contribute names to the same scope. Because the consumer of an external module decides what name to assign it, there&#39;s no need to proactively wrap up the exported
 symbols in a namespace.<br>
<br>
To reiterate why you shouldn&#39;t try to namespace your external module contents, the general idea of namespacing is to provide logical grouping of constructs and to prevent name collisions. Because the external module file itself is already a logical grouping,
 and its top-level name is defined by the code that imports it, it&#39;s unnecessary to use an additional module layer for exported objects.<br>
<br>
Revised Example:
<h6>shapes.ts</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">export</span> <span style="color:Blue">class</span> Triangle { <span style="color:Green">/* ... */</span> }
<span style="color:Blue">export</span> <span style="color:Blue">class</span> Square { <span style="color:Green">/* ... */</span> }
</pre>
</div>
<h6>shapeConsumer.ts</h6>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">import</span> shapes = require(<span style="color:#A31515">&#39;./shapes&#39;</span>);
<span style="color:Blue">var</span> t = <span style="color:Blue">new</span> shapes.Triangle(); 
</pre>
</div>
<h4>Trade-offs for External Modules</h4>
Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between external module source files and their emitted JS files. One effect of this is that it&#39;s not possible to use the
<i>--out</i> compiler switch to concatenate multiple external module source files into a single JavaScript file.<br>
<hr>
<h1 class="has-hash-nav" data-hash-nav="functions">Functions</h1>
Functions are the fundamental building block of any applications in JavaScript. They&#39;re how you build up layers of abstraction, mimicking classes, information hiding, and modules. In TypeScript, while there are classes and modules, function still play the
 key role in describing how to &#39;do&#39; things. TypeScript also adds some new capabilities to the standard JavaScript functions to make them easier to work with.<br>
<h2 class="has-hash-nav" data-hash-nav="functions-functions">Functions</h2>
To begin, just as in JavaScript, TypeScript functions can be created both as a named function or as an anonymous function. This allows you to choose the most appropriate approach for your application, whether you&#39;re building a list of functions in an API
 or a one-off function to hand off to another function.<br>
<br>
To quickly recap what these two approaches look like in JavaScript:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Green">//Named function</span>
<span style="color:Blue">function</span> add(x, y) {
    <span style="color:Blue">return</span> x&#43;y;
}

<span style="color:Green">//Anonymous function</span>
<span style="color:Blue">var</span> myAdd = <span style="color:Blue">function</span>(x, y) { <span style="color:Blue">return</span> x&#43;y; };
</pre>
</div>
<br>
Just as in JavaScript, functions can return to variables outside of the function body. When they do so, they&#39;re said to &#39;capture&#39; these variables. While understanding how this works, and the trade-offs when using this technique, are outside of the
 scope of this article, having a firm understanding how this mechanic is an important piece of working with JavaScript and TypeScript.
<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> z = 100;

<span style="color:Blue">function</span> addToZ(x, y) {
    <span style="color:Blue">return</span> x&#43;y&#43;z;
}
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="functions-function-types">Function Types</h2>
<h3>Typing the function</h3>
Let&#39;s add types to our simple examples from earlier:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> add(x: number, y: number): number {
    <span style="color:Blue">return</span> x&#43;y;
}

<span style="color:Blue">var</span> myAdd = <span style="color:Blue">function</span>(x: number, y: number): number { <span style="color:Blue">return</span> x&#43;y; };
</pre>
</div>
<br>
We can add types to each of the parameters and then to the function itself to add a return type. TypeScript can figure the return type out by looking at the return statements, so we can also optionally leave this off in many cases.<br>
<h3>Writing the function type</h3>
Now that we&#39;ve typed the function, let&#39;s write the full type of the function out by looking at the each piece of the function type.
<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> myAdd: (x:number, y:number)=&gt;number = 
    <span style="color:Blue">function</span>(x: number, y: number): number { <span style="color:Blue">return</span> x&#43;y; };
</pre>
</div>
<br>
A function&#39;s type has the same two parts: the type of the arguments and the return type. When writing out the whole function type, both parts are required. We write out the parameter types just like a parameter list, giving each parameter a name and a type.
 This name is just to help with readability. We could have instead written:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> myAdd: (baseValue:number, increment:number)=&gt;number = 
    <span style="color:Blue">function</span>(x: number, y: number): number { <span style="color:Blue">return</span> x&#43;y; };
</pre>
</div>
<br>
As long as the parameter types line up, it&#39;s considered a valid type for the function, regardless of the names you give the parameters in the function type.
<br>
<br>
The second part is the return type. We make it clear which is the return type by using a fat arrow (=&gt;) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn&#39;t return a
 value, you would use &#39;void&#39; instead of leaving it off.<br>
<br>
Of note, only the parameters and the return type make up the function type. Captured variables are not reflected in the type. In effect, captured variables are part of the &#39;hidden state&#39; of any function and do not make up its API.<br>
<h3>Inferring the types</h3>
In playing with the example, you may notice that the TypeScript compiler can figure out the type if you have types on one side of the equation but not the other:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Green">// myAdd has the full function type</span>
<span style="color:Blue">var</span> myAdd = <span style="color:Blue">function</span>(x: number, y: number): number { <span style="color:Blue">return</span> x&#43;y; };

<span style="color:Green">// The parameters &#39;x&#39; and &#39;y&#39; have the type number</span>
<span style="color:Blue">var</span> myAdd: (baseValue:number, increment:number)=&gt;number = 
    <span style="color:Blue">function</span>(x, y) { <span style="color:Blue">return</span> x&#43;y; };
</pre>
</div>
<br>
This is called &#39;contextual typing&#39;, a form of type inference. This helps cut down on the amount of effort to keep your program typed.<br>
<h2 class="has-hash-nav" data-hash-nav="functions-optional-and-default-parameters">Optional and Default Parameters</h2>
Unlike JavaScript, in TypeScript every parameter to a function is assumed to be required by the function. This doesn&#39;t mean that it isn&#39;t a &#39;null&#39; value, but rather, when the function is called the compiler will check that the user has provided
 a value for each parameter. The compiler also assumes that these parameters are the only parameters that will be passed to the function. In short, the number of parameters to the function has to match the number of parameters the function expects.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> buildName(firstName: string, lastName: string) {
    <span style="color:Blue">return</span> firstName &#43; <span style="color:#A31515">&quot; &quot;</span> &#43; lastName;
}

<span style="color:Blue">var</span> result1 = buildName(<span style="color:#A31515">&quot;Bob&quot;</span>);  <span style="color:Green">//error, too few parameters</span>
<span style="color:Blue">var</span> result2 = buildName(<span style="color:#A31515">&quot;Bob&quot;</span>, <span style="color:#A31515">&quot;Adams&quot;</span>, <span style="color:#A31515">&quot;Sr.&quot;</span>);  <span style="color:Green">//error, too many parameters</span>
<span style="color:Blue">var</span> result3 = buildName(<span style="color:#A31515">&quot;Bob&quot;</span>, <span style="color:#A31515">&quot;Adams&quot;</span>);  <span style="color:Green">//ah, just right</span>
</pre>
</div>
<br>
In JavaScript, every parameter is considered optional, and users may leave them off as they see fit. When they do, they&#39;re assumed to be undefined. We can get this functionality in TypeScript by using the &#39;?&#39; beside parameters we want optional.
 For example, let&#39;s say we want the last name to be optional:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> buildName(firstName: string, lastName?: string) {
    <span style="color:Blue">if</span> (lastName)
        <span style="color:Blue">return</span> firstName &#43; <span style="color:#A31515">&quot; &quot;</span> &#43; lastName;
    <span style="color:Blue">else</span>
        <span style="color:Blue">return</span> firstName;
}

<span style="color:Blue">var</span> result1 = buildName(<span style="color:#A31515">&quot;Bob&quot;</span>);  <span style="color:Green">//works correctly now</span>
<span style="color:Blue">var</span> result2 = buildName(<span style="color:#A31515">&quot;Bob&quot;</span>, <span style="color:#A31515">&quot;Adams&quot;</span>, <span style="color:#A31515">&quot;Sr.&quot;</span>);  <span style="color:Green">//error, too many parameters</span>
<span style="color:Blue">var</span> result3 = buildName(<span style="color:#A31515">&quot;Bob&quot;</span>, <span style="color:#A31515">&quot;Adams&quot;</span>);  <span style="color:Green">//ah, just right</span>
</pre>
</div>
<br>
Optional parameters must follow required parameters. Had we wanted to make the first name optional rather than the last name, we would need to change the order of parameters in the function, putting the first name last in the list.<br>
<br>
In TypeScript, we can also set up a value that an optional parameter will have if the user does not provide one. These are called default parameters. Let&#39;s take the previous example and default the last name to &quot;Smith&quot;.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> buildName(firstName: string, lastName = <span style="color:#A31515">&quot;Smith&quot;</span>) {
    <span style="color:Blue">return</span> firstName &#43; <span style="color:#A31515">&quot; &quot;</span> &#43; lastName;
}

<span style="color:Blue">var</span> result1 = buildName(<span style="color:#A31515">&quot;Bob&quot;</span>);  <span style="color:Green">//works correctly now, also</span>
<span style="color:Blue">var</span> result2 = buildName(<span style="color:#A31515">&quot;Bob&quot;</span>, <span style="color:#A31515">&quot;Adams&quot;</span>, <span style="color:#A31515">&quot;Sr.&quot;</span>);  <span style="color:Green">//error, too many parameters</span>
<span style="color:Blue">var</span> result3 = buildName(<span style="color:#A31515">&quot;Bob&quot;</span>, <span style="color:#A31515">&quot;Adams&quot;</span>);  <span style="color:Green">//ah, just right</span>
</pre>
</div>
<br>
Just as with optional parameters, default parameters must come after required parameters in the parameter list.
<br>
<br>
Optional parameters and default parameters also share what the type looks like. Both:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> buildName(firstName: string, lastName?: string) {
</pre>
</div>
<br>
and<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> buildName(firstName: string, lastName = <span style="color:#A31515">&quot;Smith&quot;</span>) {
</pre>
</div>
<br>
share the same type &quot;(firstName: string, lastName?: string)=&gt;string&quot;. The default value of the default parameter disappears, leaving only the knowledge that the parameter is optional.<br>
<h2 class="has-hash-nav" data-hash-nav="functions-rest-parameters">Rest Parameters</h2>
Required, optional, and default parameters all have one thing in common: they&#39;re about talking about one parameter at a time. Sometimes, you want to work with multiple parameters as a group, or you may not know how many parameters a function will ultimately
 take. In JavaScript, you can work with the arguments direction using the <span class="codeInline">
arguments</span> variable that is visible inside every function body.<br>
<br>
In TypeScript, you can gather these arguments together into a variable:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> buildName(firstName: string, ...restOfName: string[]) {
	<span style="color:Blue">return</span> firstName &#43; <span style="color:#A31515">&quot; &quot;</span> &#43; restOfName.join(<span style="color:#A31515">&quot; &quot;</span>);
}

<span style="color:Blue">var</span> employeeName = buildName(<span style="color:#A31515">&quot;Joseph&quot;</span>, <span style="color:#A31515">&quot;Samuel&quot;</span>, <span style="color:#A31515">&quot;Lucas&quot;</span>, <span style="color:#A31515">&quot;MacKinzie&quot;</span>);
</pre>
</div>
<br>
Rest parameters are treated as a boundless number of optional parameters. You may leave them off, or have as many as you want. The compiler will build an array of the arguments you pass to the function under the name given after the ellipsis (...), allowing
 you to use it in your function. <br>
<br>
The ellipsis is also used in the type of the function with rest parameters:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> buildName(firstName: string, ...restOfName: string[]) {
	<span style="color:Blue">return</span> firstName &#43; <span style="color:#A31515">&quot; &quot;</span> &#43; restOfName.join(<span style="color:#A31515">&quot; &quot;</span>);
}

<span style="color:Blue">var</span> buildNameFun: (fname: string, ...rest: string[])=&gt;string = buildName;
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="functions-lambdas-and-using-39this39">Lambdas and using &#39;this&#39;</h2>
How &#39;this&#39; works in JavaScript functions is a common theme in programmers coming to JavaScript. Indeed, learning how to use it is something of a rite of passage as developers become more accustomed to working in JavaScript. Since TypeScript is a superset
 of JavaScript, TypeScript developers also need to learn how to use &#39;this&#39; and how to spot when it&#39;s not being used correctly. A whole article could be written on how to use &#39;this&#39; in JavaScript, and many have. Here, we&#39;ll focus on some
 of the basics. <br>
<br>
In JavaScript, &#39;this&#39; is a variable that&#39;s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This can be notoriously
 confusing, when, for example, when a function is used as a callback.<br>
<br>
Let&#39;s look at an example:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> deck = {
    suits: [<span style="color:#A31515">&quot;hearts&quot;</span>, <span style="color:#A31515">&quot;spades&quot;</span>, <span style="color:#A31515">&quot;clubs&quot;</span>, <span style="color:#A31515">&quot;diamonds&quot;</span>],
    cards: Array(52),
    createCardPicker: <span style="color:Blue">function</span>() {
        <span style="color:Blue">return</span> <span style="color:Blue">function</span>() {
            <span style="color:Blue">var</span> pickedCard = Math.floor(Math.random() * 52);
            <span style="color:Blue">var</span> pickedSuit = Math.floor(pickedCard / 13);
			
            <span style="color:Blue">return</span> {suit: <span style="color:Blue">this</span>.suits[pickedSuit], card: pickedCard % 13};
        }
    }
}

<span style="color:Blue">var</span> cardPicker = deck.createCardPicker();
<span style="color:Blue">var</span> pickedCard = cardPicker();

alert(<span style="color:#A31515">&quot;card: &quot;</span> &#43; pickedCard.card &#43; <span style="color:#A31515">&quot; of &quot;</span> &#43; pickedCard.suit);
</pre>
</div>
<br>
If we tried to run the example, we would get an error instead of the expected alert box. This is because the &#39;this&#39; being used in the function created by &#39;createCardPicker&#39; will be set to &#39;window&#39; instead of our &#39;deck&#39; object.
 This happens as a result of calling &#39;cardPicker()&#39;. Here, there is no dynamic binding for &#39;this&#39; other than Window. (note: under strict mode, this will be undefined rather than window).<br>
<br>
We can fix this by making sure the function is bound to the correct &#39;this&#39; before we return the function to be used later. This way, regardless of how its later used, it will still be able to see the original &#39;deck&#39; object.<br>
<br>
To fix this, we switching the function expression to use the lambda syntax ( ()=&gt;{} ) rather than the JavaScript function expression. This will automatically capture the &#39;this&#39; available when the function is created rather than when it is invoked:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> deck = {
    suits: [<span style="color:#A31515">&quot;hearts&quot;</span>, <span style="color:#A31515">&quot;spades&quot;</span>, <span style="color:#A31515">&quot;clubs&quot;</span>, <span style="color:#A31515">&quot;diamonds&quot;</span>],
    cards: Array(52),
    createCardPicker: <span style="color:Blue">function</span>() {
        <span style="color:Green">// Notice: the line below is now a lambda, allowing us to capture &#39;this&#39; earlier</span>
        <span style="color:Blue">return</span> () =&gt; {
            <span style="color:Blue">var</span> pickedCard = Math.floor(Math.random() * 52);
            <span style="color:Blue">var</span> pickedSuit = Math.floor(pickedCard / 13);
			
            <span style="color:Blue">return</span> {suit: <span style="color:Blue">this</span>.suits[pickedSuit], card: pickedCard % 13};
        }
    }
}

<span style="color:Blue">var</span> cardPicker = deck.createCardPicker();
<span style="color:Blue">var</span> pickedCard = cardPicker();

alert(<span style="color:#A31515">&quot;card: &quot;</span> &#43; pickedCard.card &#43; <span style="color:#A31515">&quot; of &quot;</span> &#43; pickedCard.suit);
</pre>
</div>
<br>
For more information on ways to think about &#39;this&#39;, you can read Yahuda Katz&#39;s
<a href="http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/">
Understanding JavaScript Function Invocation and this</a>.<br>
<h2 class="has-hash-nav" data-hash-nav="functions-overloads">Overloads</h2>
JavaScript is inherently a very dynamic language. It&#39;s not uncommon for a single JavaScript function to return different types of objects based on the shape of the arguments passed in.
<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> suits = [<span style="color:#A31515">&quot;hearts&quot;</span>, <span style="color:#A31515">&quot;spades&quot;</span>, <span style="color:#A31515">&quot;clubs&quot;</span>, <span style="color:#A31515">&quot;diamonds&quot;</span>];

<span style="color:Blue">function</span> pickCard(x): any {
    <span style="color:Green">// Check to see if we&#39;re working with an object/array</span>
    <span style="color:Green">// if so, they gave us the deck and we&#39;ll pick the card</span>
    <span style="color:Blue">if</span> (<span style="color:Blue">typeof</span> x == <span style="color:#A31515">&quot;object&quot;</span>) {
        <span style="color:Blue">var</span> pickedCard = Math.floor(Math.random() * x.length);
        <span style="color:Blue">return</span> pickedCard;
    }
    <span style="color:Green">// Otherwise just let them pick the card</span>
    <span style="color:Blue">else</span> <span style="color:Blue">if</span> (<span style="color:Blue">typeof</span> x == <span style="color:#A31515">&quot;number&quot;</span>) {
        <span style="color:Blue">var</span> pickedSuit = Math.floor(x / 13);
        <span style="color:Blue">return</span> { suit: suits[pickedSuit], card: x % 13 };
    }
}

<span style="color:Blue">var</span> myDeck = [{ suit: <span style="color:#A31515">&quot;diamonds&quot;</span>, card: 2 }, { suit: <span style="color:#A31515">&quot;spades&quot;</span>, card: 10 }, { suit: <span style="color:#A31515">&quot;hearts&quot;</span>, card: 4 }];
<span style="color:Blue">var</span> pickedCard1 = myDeck[pickCard(myDeck)];
alert(<span style="color:#A31515">&quot;card: &quot;</span> &#43; pickedCard1.card &#43; <span style="color:#A31515">&quot; of &quot;</span> &#43; pickedCard1.suit);

<span style="color:Blue">var</span> pickedCard2 = pickCard(15);
alert(<span style="color:#A31515">&quot;card: &quot;</span> &#43; pickedCard2.card &#43; <span style="color:#A31515">&quot; of &quot;</span> &#43; pickedCard2.suit);
</pre>
</div>
<br>
Here the &#39;pickCard&#39; function will return two different things based on what the user has passed in. If the users passes in an object that represents the deck, the function will pick the card. If the user picks the card, we tell them which card they&#39;ve
 picked. But how do we describe this to the type system.<br>
<br>
The answer is to supply multiple function types for the same function as a list of overloads. This list is what the compiler will use to resolve function calls. Let&#39;s create a list of overloads that describe what our &#39;pickCard&#39; accepts and what
 it returns.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> suits = [<span style="color:#A31515">&quot;hearts&quot;</span>, <span style="color:#A31515">&quot;spades&quot;</span>, <span style="color:#A31515">&quot;clubs&quot;</span>, <span style="color:#A31515">&quot;diamonds&quot;</span>];

<span style="color:Blue">function</span> pickCard(x: {suit: string; card: number; }[]): number;
<span style="color:Blue">function</span> pickCard(x: number): {suit: string; card: number; };
<span style="color:Blue">function</span> pickCard(x): any {
    <span style="color:Green">// Check to see if we&#39;re working with an object/array</span>
    <span style="color:Green">// if so, they gave us the deck and we&#39;ll pick the card</span>
    <span style="color:Blue">if</span> (<span style="color:Blue">typeof</span> x == <span style="color:#A31515">&quot;object&quot;</span>) {
        <span style="color:Blue">var</span> pickedCard = Math.floor(Math.random() * x.length);
        <span style="color:Blue">return</span> pickedCard;
    }
    <span style="color:Green">// Otherwise just let them pick the card</span>
    <span style="color:Blue">else</span> <span style="color:Blue">if</span> (<span style="color:Blue">typeof</span> x == <span style="color:#A31515">&quot;number&quot;</span>) {
        <span style="color:Blue">var</span> pickedSuit = Math.floor(x / 13);
        <span style="color:Blue">return</span> { suit: suits[pickedSuit], card: x % 13 };
    }
}

<span style="color:Blue">var</span> myDeck = [{ suit: <span style="color:#A31515">&quot;diamonds&quot;</span>, card: 2 }, { suit: <span style="color:#A31515">&quot;spades&quot;</span>, card: 10 }, { suit: <span style="color:#A31515">&quot;hearts&quot;</span>, card: 4 }];
<span style="color:Blue">var</span> pickedCard1 = myDeck[pickCard(myDeck)];
alert(<span style="color:#A31515">&quot;card: &quot;</span> &#43; pickedCard1.card &#43; <span style="color:#A31515">&quot; of &quot;</span> &#43; pickedCard1.suit);

<span style="color:Blue">var</span> pickedCard2 = pickCard(15);
alert(<span style="color:#A31515">&quot;card: &quot;</span> &#43; pickedCard2.card &#43; <span style="color:#A31515">&quot; of &quot;</span> &#43; pickedCard2.suit);
</pre>
</div>
<br>
With this change, the overloads now give us type-checked calls to the &#39;pickCard&#39; function.
<br>
<br>
In order for the compiler to pick the correct typecheck, it follows a similar process to the underlying JavaScript. It looks at the overload list, and proceeding with the first overload attempts to call the function with the provided parameters. If it finds
 a match, it picks this overload as the correct overload. For this reason, its customary to order overloads from most specific to least specific.<br>
<br>
Note that the &#39;function pickCard(x): any&#39; piece is not part of the overload list, so it only has two overloads: one that takes an object and one that takes a number. Calling &#39;pickCard&#39; with any other parameter types would cause an error.<br>
<br>
<br>
<hr>
<h1 class="has-hash-nav" data-hash-nav="generics">Generics</h1>
A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable. Components that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible
 capabilities for building up large software systems.<br>
<br>
In languages like C# and Java, one of the main tools in the toolbox for creating reusable components is &#39;generics&#39;, that is, being able to create a component that can work over a variety of types rather than a single one. This allows users to consume
 these components and use their own types.<br>
<h2 class="has-hash-nav" data-hash-nav="generics-hello-world-of-generics">Hello World of Generics</h2>
To start off, let&#39;s do the &quot;hello world&quot; of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the &#39;echo&#39; command.
<br>
<br>
Without generics, we would either have to give the identity function a specific type:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> identity(arg: number): number {
    <span style="color:Blue">return</span> arg;
}
</pre>
</div>
<br>
Or, we could describe the identity function using the &#39;any&#39; type:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> identity(arg: any): any {
    <span style="color:Blue">return</span> arg;
}
</pre>
</div>
<br>
While using &#39;any&#39; is certainly generic in that will accept any and all types for the type of &#39;arg&#39;, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we
 have is that any type could be returned. <br>
<br>
Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a
<i>type variable</i>, a special kind of variable that works on types rather than values.
<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> identity&lt;T&gt;(arg: T): T {
    <span style="color:Blue">return</span> arg;
}
</pre>
</div>
<br>
We&#39;ve now added a type variable &#39;T&#39; to the identity function. This &#39;T&#39; allows us to capture the type the user provides (eg, number), so that we can use that information later. Here, we use &#39;T&#39; again as the return type. On inspection,
 we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other.<br>
<br>
We say that this version of the &#39;identity&#39; function is generic, as it works over a range of types. Unlike using &#39;any&#39;, it&#39;s also just as precise (ie, it doesn&#39;t lose any information) as the first &#39;identity&#39; function that used
 numbers for the argument and return type.<br>
<br>
Once we&#39;ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> output = identity&lt;string&gt;(<span style="color:#A31515">&quot;myString&quot;</span>);  <span style="color:Green">// type of output will be &#39;string&#39;</span>
</pre>
</div>
<br>
Here we explicitly set &#39;T&#39; to be string as one of the arguments to the function call, denoted using the &lt;&gt; around the arguments rather than ().<br>
<br>
The second way is also perhaps the most common. Here we use /type argument inference/, that is, we want the compiler to set the value of T for us automatically based on the type of the argument we pass in:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> output = identity(<span style="color:#A31515">&quot;myString&quot;</span>);  <span style="color:Green">// type of output will be &#39;string&#39;</span>
</pre>
</div>
<br>
Notice that we didn&#39;t have explicitly pass the type in the angle brackets (&lt;&gt;), the compiler just looked at the value &quot;myString&quot;, and set T to its type. While type argument inference can be a helpful tool to keep code shorter and more readable,
 you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.<br>
<h2 class="has-hash-nav" data-hash-nav="generics-working-with-generic-type-variables">Working with Generic Type Variables</h2>
When you begin to use generics, you&#39;ll notice that when you create generic functions like &#39;identity&#39;, the compiler will enforce that you use any generically typed parameters in the body of the function correctly. That is, that you actually treat
 these parameters as if they could be any and all types.<br>
<br>
Let&#39;s take our &#39;identity&#39; function from earlier:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> identity&lt;T&gt;(arg: T): T {
    <span style="color:Blue">return</span> arg;
}
</pre>
</div>
<br>
What if want to also log the length of the argument &#39;arg&#39; to the console with each call. We might be tempted to write this:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> loggingIdentity&lt;T&gt;(arg: T): T {
    console.log(arg.length);  <span style="color:Green">// Error: T doesn&#39;t have .length</span>
    <span style="color:Blue">return</span> arg;
}
</pre>
</div>
<br>
When we do, the compiler will give us an error that we&#39;re using the &quot;.length&quot; member of &#39;arg&#39;, but nowhere have we said that &#39;arg&#39; has this member. Remember, we said earlier that these type variables stand in for any and all types,
 so someone using this function could have passed in a &#39;number&#39; instead, which does not have a &quot;.length&quot; member.
<br>
<br>
Let&#39;s say that we&#39;ve actually intended this function to work on arrays of T rather that T directly. Since we&#39;re working with arrays, the .length member should be available. We can describe this just like we would create arrays of other types:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> loggingIdentity&lt;T&gt;(arg: T[]): T[] {
    console.log(arg.length);  <span style="color:Green">// Array has a .length, so no more error</span>
    <span style="color:Blue">return</span> arg;
}
</pre>
</div>
<br>
You can read the type of logging Identity as &quot;the generic function loggingIdentity, takes a type parameter T, and an argument &#39;arg&#39; which is an array of these T&#39;s, and returns an array of T&#39;s. If we passed in an array of numbers, we&#39;d
 get an array of numbers back out, as T would bind to number. This allows us to use our generic type variable &#39;T&#39; as part of the types we&#39;re working with, rather than the whole type, giving us greater flexibility.
<br>
<br>
We can alternatively write the sample example this way:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> loggingIdentity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; {
    console.log(arg.length);  <span style="color:Green">// Array has a .length, so no more error</span>
    <span style="color:Blue">return</span> arg;
}
</pre>
</div>
<br>
You may already be familiar with this style of type from other languages. In the next section, we&#39;ll cover how you can create your own generic types like Array&lt;T&gt;.<br>
<h2 class="has-hash-nav" data-hash-nav="generics-generic-types">Generic Types</h2>
In previous sections, we created generic identity functions that worked over a range of types. In this section, we&#39;ll explore the type of the functions themselves and how to create generic interfaces.<br>
<br>
The type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> identity&lt;T&gt;(arg: T): T {
    <span style="color:Blue">return</span> arg;
}

<span style="color:Blue">var</span> myIdentity: &lt;T&gt;(arg: T)=&gt;T = identity;
</pre>
</div>
<br>
We could also have used a different name for the generic type parameter in the type, so long as the number of type variables and how the type variables are used line up.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> identity&lt;T&gt;(arg: T): T {
    <span style="color:Blue">return</span> arg;
}

<span style="color:Blue">var</span> myIdentity: &lt;U&gt;(arg: U)=&gt;U = identity;
</pre>
</div>
<br>
We can also write the generic type as a call signature of an object literal type:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> identity&lt;T&gt;(arg: T): T {
    <span style="color:Blue">return</span> arg;
}

<span style="color:Blue">var</span> myIdentity: {&lt;T&gt;(arg: T): T} = identity;
</pre>
</div>
<br>
Which leads us to writing our first generic interface. Let&#39;s take the object literal from the previous example and move it to an interface:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> GenericIdentityFn {
    &lt;T&gt;(arg: T): T;
}

<span style="color:Blue">function</span> identity&lt;T&gt;(arg: T): T {
    <span style="color:Blue">return</span> arg;
}

<span style="color:Blue">var</span> myIdentity: GenericIdentityFn = identity;
</pre>
</div>
<br>
In a similar example, we may want to move the generic parameter to be a parameter of the whole interface. This lets us see what type(s) we&#39;re generic over (eg Dictionary&lt;string&gt; rather than just Dictionary). This makes the type parameter visible to
 all the other members of the interface. <br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> GenericIdentityFn&lt;T&gt; {
    (arg: T): T;
}

<span style="color:Blue">function</span> identity&lt;T&gt;(arg: T): T {
    <span style="color:Blue">return</span> arg;
}

<span style="color:Blue">var</span> myIdentity: GenericIdentityFn&lt;number&gt; = identity;
</pre>
</div>
<br>
Notice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use GenericIdentityFn, we now will also need to specify
 the corresponding type argument (here: number), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing
 what aspects of a type are generic.<br>
<br>
In addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and modules.<br>
<h2 class="has-hash-nav" data-hash-nav="generics-generic-classes">Generic Classes</h2>
A generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets (&lt;&gt;) following the name of the class.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">class</span> GenericNumber&lt;T&gt; {
    zeroValue: T;
    add: (x: T, y: T) =&gt; T;
}

<span style="color:Blue">var</span> myGenericNumber = <span style="color:Blue">new</span> GenericNumber&lt;number&gt;();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = <span style="color:Blue">function</span>(x, y) { <span style="color:Blue">return</span> x &#43; y; };
</pre>
</div>
<br>
This is a pretty literal use of the &#39;GenericNumber&#39; class, but you may have noticed that nothing is restricting is to only use the &#39;number&#39; type. We could have instead used &#39;string&#39; or even more complex objects.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> stringNumeric = <span style="color:Blue">new</span> GenericNumber&lt;string&gt;();
stringNumeric.zeroValue = <span style="color:#A31515">&quot;&quot;</span>;
stringNumeric.add = <span style="color:Blue">function</span>(x, y) { <span style="color:Blue">return</span> x &#43; y; };

alert(stringNumeric.add(stringNumeric.zeroValue, <span style="color:#A31515">&quot;test&quot;</span>));
</pre>
</div>
<br>
Just as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type.<br>
<br>
As we covered in <a href="https://typescript.codeplex.com/wikipage?title=Classes%20in%20TypeScript&referringTitle=Generics%20in%20TypeScript">
Classes</a>, a class has two side to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class&#39;s type parameter.<br>
<h2 class="has-hash-nav" data-hash-nav="generics-generic-constraints">Generic Constraints</h2>
If you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have. In our &#39;loggingIdentity&#39; example, we wanted to
 be able access the &quot;.length&quot; property of &#39;arg&#39;, but the compiler could not prove that every type had a &quot;.length&quot; property, so it warns us that we can&#39;t make this assumption.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> loggingIdentity&lt;T&gt;(arg: T): T {
    console.log(arg.length);  <span style="color:Green">// Error: T doesn&#39;t have .length</span>
    <span style="color:Blue">return</span> arg;
}
</pre>
</div>
<br>
Instead of working with any and all types, we&#39;d like to constrain this function to work with any and all types that also have the &quot;.length&quot; property. As long as the type has this member, we&#39;ll allow it, but it&#39;s required to have at least
 this member. To do so, we must list our requirement as a constraint on what T can be.<br>
<br>
To do so, we&#39;ll create an interface that describes our constraint. Here, we&#39;ll create an interface that has a single &quot;.length&quot; property and then we&#39;ll use this interface and the
<span class="codeInline">extends</span> keyword to denote our constraint:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> Lengthwise {
    length: number;
}

<span style="color:Blue">function</span> loggingIdentity&lt;T <span style="color:Blue">extends</span> Lengthwise&gt;(arg: T): T {
    console.log(arg.length);  <span style="color:Green">// Now we know it has a .length property, so no more error</span>
    <span style="color:Blue">return</span> arg;
}
</pre>
</div>
<br>
Because the generic function is now constrained, it will no longer work over any and all types:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
loggingIdentity(3);  <span style="color:Green">// Error, number doesn&#39;t have a .length property</span>
</pre>
</div>
<br>
Instead, we need to pass in values whose type has all the required properties:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
loggingIdentity({length: 10, value: 3});  
</pre>
</div>
<h3>Using Type Parameters in Generic Constraints</h3>
In some cases, it may be useful to declare a type parameter that is constrained by another type parameter. For example,<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> find&lt;T, U <span style="color:Blue">extends</span> Findable&lt;T&gt;&gt;(n: T, s: U) {   <span style="color:Green">// errors because type parameter used in constraint</span>
  <span style="color:Green">// ...</span>
} 
find (giraffe, myAnimals);
</pre>
</div>
<br>
You can achieve the pattern above by replacing the type parameter with its constraint. Rewriting the example above,<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> find&lt;T&gt;(n: T, s: Findable&lt;T&gt;) {   
  <span style="color:Green">// ...</span>
} 
find(giraffe, myAnimals);
</pre>
</div>
<br>
<i>Note:</i> The above is not strictly identical, as the return type of the first function could have returned &#39;U&#39;, which the second function pattern does not provide a means to do.<br>
<h3>Using Class Types in Generics</h3>
When creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example,<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> create&lt;T&gt;(c: {<span style="color:Blue">new</span>(): T; }): T { 
    <span style="color:Blue">return</span> <span style="color:Blue">new</span> c();
}
</pre>
</div>
<br>
A more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">class</span> BeeKeeper {
    hasMask: <span style="color:Blue">boolean</span>;
}

<span style="color:Blue">class</span> ZooKeeper {
    nametag: string; 
}

<span style="color:Blue">class</span> Animal {
    numLegs: number;
}

<span style="color:Blue">class</span> Bee <span style="color:Blue">extends</span> Animal {
    keeper: BeeKeeper;
}

<span style="color:Blue">class</span> Lion <span style="color:Blue">extends</span> Animal {
    keeper: ZooKeeper;
}

<span style="color:Blue">function</span> findKeeper&lt;A <span style="color:Blue">extends</span> Animal, K&gt; (a: {<span style="color:Blue">new</span>(): A; 
    prototype: {keeper: K}}): K {

    <span style="color:Blue">return</span> a.prototype.keeper;
}

findKeeper(Lion).nametag;  <span style="color:Green">// typechecks!</span>
</pre>
</div>

<h1 class="has-hash-nav" data-hash-nav="common-errors">Common Errors</h1>
The list below captures some of the commonly confusing error messages that you may encounter when using the TypeScript language and Compiler<br>
<h2 class="has-hash-nav" data-hash-nav="common-errors-commonly-confusing-errors">Commonly Confusing Errors</h2>
<h3>&quot;tsc.exe&quot; exited with error code 1.</h3>
<b>Fixes:</b>
<ul>
<li>check file-encoding is UTF-8 - <a href="https://typescript.codeplex.com/workitem/1587">
https://typescript.codeplex.com/workitem/1587</a></li></ul>
<h3>external module XYZ cannot be resolved</h3>
<b>Fixes:</b>
<ul>
<li>check if module path is case-sensitive - <a href="https://typescript.codeplex.com/workitem/2134">
https://typescript.codeplex.com/workitem/2134</a></li></ul>
<br>
<hr>
<h1 class="has-hash-nav" data-hash-nav="mixins">Mixins</h1>
Along with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes. You may be familiar with the idea of mixins or traits for languages like Scala, and the pattern
 has also reached some popularity in the JavaScript community.<br>
<h2 class="has-hash-nav" data-hash-nav="mixins-mixin-sample">Mixin sample</h2>
In the code below, we show how you can model mixins in TypeScript. After the code, we&#39;ll break down how it works.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Green">// Disposable Mixin</span>
<span style="color:Blue">class</span> Disposable {
    isDisposed: <span style="color:Blue">boolean</span>;
    dispose() {
        <span style="color:Blue">this</span>.isDisposed = <span style="color:Blue">true</span>;
    }
 
}
 
<span style="color:Green">// Activatable Mixin</span>
<span style="color:Blue">class</span> Activatable {
    isActive: <span style="color:Blue">boolean</span>;
    activate() {
        <span style="color:Blue">this</span>.isActive = <span style="color:Blue">true</span>;
    }
    deactivate() {
        <span style="color:Blue">this</span>.isActive = <span style="color:Blue">false</span>;
    }
}
 
<span style="color:Blue">class</span> SmartObject <span style="color:Blue">implements</span> Disposable, Activatable {
    constructor() {
        setInterval(() =&gt; console.log(<span style="color:Blue">this</span>.isActive &#43; <span style="color:#A31515">&quot; : &quot;</span> &#43; <span style="color:Blue">this</span>.isDisposed), 500);
    }
 
    interact() {
        <span style="color:Blue">this</span>.activate();
    }
 
    <span style="color:Green">// Disposable</span>
    isDisposed: <span style="color:Blue">boolean</span> = <span style="color:Blue">false</span>;
    dispose: () =&gt; <span style="color:Blue">void</span>;
    <span style="color:Green">// Activatable</span>
    isActive: <span style="color:Blue">boolean</span> = <span style="color:Blue">false</span>;
    activate: () =&gt; <span style="color:Blue">void</span>;
    deactivate: () =&gt; <span style="color:Blue">void</span>;
}
applyMixins(SmartObject, [Disposable, Activatable])
 
<span style="color:Blue">var</span> smartObj = <span style="color:Blue">new</span> SmartObject();
setTimeout(() =&gt; smartObj.interact(), 1000);
 
<span style="color:Green">////////////////////////////////////////</span>
<span style="color:Green">// In your runtime library somewhere</span>
<span style="color:Green">////////////////////////////////////////</span>

<span style="color:Blue">function</span> applyMixins(derivedCtor: any, baseCtors: any[]) {
    baseCtors.forEach(baseCtor =&gt; {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; {
            derivedCtor.prototype[name] = baseCtor.prototype[name];
        })
    }); 
}
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="mixins-understanding-the-sample">Understanding the sample</h2>
The code sample starts with the two classes that will act is our mixins. You can see each one is focused on a particular activity or capability. We&#39;ll later mix these together to form a new class from both capabilities.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Green">// Disposable Mixin</span>
<span style="color:Blue">class</span> Disposable {
    isDisposed: <span style="color:Blue">boolean</span>;
    dispose() {
        <span style="color:Blue">this</span>.isDisposed = <span style="color:Blue">true</span>;
    }
 
}
 
<span style="color:Green">// Activatable Mixin</span>
<span style="color:Blue">class</span> Activatable {
    isActive: <span style="color:Blue">boolean</span>;
    activate() {
        <span style="color:Blue">this</span>.isActive = <span style="color:Blue">true</span>;
    }
    deactivate() {
        <span style="color:Blue">this</span>.isActive = <span style="color:Blue">false</span>;
    }
}
</pre>
</div>
<br>
Next, we&#39;ll create the class that will handle the combination of the two mixins. Let&#39;s look at this in more detail to see how it does this:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">class</span> SmartObject <span style="color:Blue">implements</span> Disposable, Activatable {
</pre>
</div>
<br>
The first thing you may notice in the above is that instead of using &#39;extends&#39;, we use &#39;implements&#39;. This treats the classes as interfaces, and only uses the types behind Disposable and Activatable rather than the implementation. This means
 that we&#39;ll have to provide the implementation in class. Except, that&#39;s exactly what we want to avoid by using mixins.
<br>
<br>
To satisfy this requirement, we create stand-in properties and their types for the members that will come from our mixins. This satisfies the compiler that these members will be available at runtime. This lets us still get the benefit of the mixins, albeit
 with a some bookkeeping overhead.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Green">// Disposable</span>
isDisposed: <span style="color:Blue">boolean</span> = <span style="color:Blue">false</span>;
dispose: () =&gt; <span style="color:Blue">void</span>;
<span style="color:Green">// Activatable</span>
isActive: <span style="color:Blue">boolean</span> = <span style="color:Blue">false</span>;
activate: () =&gt; <span style="color:Blue">void</span>;
deactivate: () =&gt; <span style="color:Blue">void</span>;
</pre>
</div>
<br>
Finally, we mix our mixins into the class, creating the full implementation.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
applyMixins(SmartObject, [Disposable, Activatable])
</pre>
</div>
<br>
Lastly, we create a helper function that will do the mixing for us. This will run through the properties of each of the mixins and copy them over to the target of the mixins, filling out the stand-in properties with their implementations.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> applyMixins(derivedCtor: any, baseCtors: any[]) {
    baseCtors.forEach(baseCtor =&gt; {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name =&gt; {
            derivedCtor.prototype[name] = baseCtor.prototype[name];
        })
    }); 
}

</pre>
</div>
<br>
<h1 class="has-hash-nav" data-hash-nav="declaration-merging">Declaration Merging</h1>
Some of the unique concepts in TypeScript come from the need to describe what is happening to the shape of JavaScript objects at the type level. One example that is especially unique to TypeScript is the concept of &#39;declaration merging&#39;. Understanding
 this concept will give you an advantage when working with existing JavaScript in your TypeScript. It also opens the door to more advanced abstraction concepts.<br>
<br>
First, before we get into how declarations merge, let&#39;s first describe what we mean by &#39;declaration merging&#39;.<br>
<br>
For the purposes of this article, declaration merging specifically means that the compiler is doing the work of merging two separate declarations declared with the same name into a single definition. This merged definition has the features of both of the original
 declarations. Declaration merging is not limited to just two declarations, as any number of declarations can be merged.
<br>
<h2 class="has-hash-nav" data-hash-nav="declaration-merging-basic-concepts">Basic Concepts</h2>
In TypeScript, a declaration exists in one of three groups: namespace/module, type, or value. Declarations that create a namespace/module are accessed using a dotted notation when writing a type. Declarations that create a type do just that, create a type that
 is visible with the declared shape and bound to the given name. Lastly, declarations create a value are those that are visible in the output JavaScript (eg, functions and variables).<br>
<br>
<table>
<tbody>
<tr>
<th>Declaration Type </th>
<th>Namespace </th>
<th>Type </th>
<th>Value </th>
</tr>
<tr>
<td>Module </td>
<td>X </td>
<td></td>
<td>X </td>
</tr>
<tr>
<td>Class </td>
<td></td>
<td>X </td>
<td>X </td>
</tr>
<tr>
<td>Interface </td>
<td></td>
<td>X </td>
<td></td>
</tr>
<tr>
<td>Function </td>
<td></td>
<td></td>
<td>X </td>
</tr>
<tr>
<td>Variable </td>
<td></td>
<td></td>
<td>X </td>
</tr>
</tbody>
</table>
<br>
<br>
Understanding what is created with each declaration will help you understand what is merged when you perform a declaration merge.<br>
<h2 class="has-hash-nav" data-hash-nav="declaration-merging-merging-interfaces">Merging Interfaces</h2>
The simplest, and perhaps most common, type of declaration merging is interface merging. At the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> Box {
    height: number;
    width: number;
}

<span style="color:Blue">interface</span> Box {
    scale: number;
}

<span style="color:Blue">var</span> box: Box = {height: 5, width: 6, scale: 10};
</pre>
</div>
<br>
Non-function members of the interfaces must be unique. The compiler will issue an error if the interfaces both declare a non-function member of the same name.<br>
<br>
For function members, each function member of the same name is treated as describing an overload of the same function. Of note, too, is that in the case of interface A merging with later interface A (here called A&#39;), the overload set of A&#39; will have
 a higher precedence than that of interface A. <br>
<br>
That is, in the example:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> Document {
    createElement(tagName: any): Element;
}
<span style="color:Blue">interface</span> Document {
    createElement(tagName: string): HTMLElement;
}
<span style="color:Blue">interface</span> Document {
    createElement(tagName: <span style="color:#A31515">&quot;div&quot;</span>): HTMLDivElement; 
    createElement(tagName: <span style="color:#A31515">&quot;span&quot;</span>): HTMLSpanElement;
    createElement(tagName: <span style="color:#A31515">&quot;canvas&quot;</span>): HTMLCanvasElement;
}
</pre>
</div>
<br>
The two interfaces will merge to create a single declaration. Notice that the elements of each group maintains the same order, just the groups themselves are merged with later overload sets coming first:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> Document {
    createElement(tagName: <span style="color:#A31515">&quot;div&quot;</span>): HTMLDivElement; 
    createElement(tagName: <span style="color:#A31515">&quot;span&quot;</span>): HTMLSpanElement;
    createElement(tagName: <span style="color:#A31515">&quot;canvas&quot;</span>): HTMLCanvasElement;
    createElement(tagName: string): HTMLElement;
    createElement(tagName: any): Element;
}
</pre>
</div>
<br>
<h2 class="has-hash-nav" data-hash-nav="declaration-merging-merging-modules">Merging Modules</h2>
Similarly to interfaces, modules of the same name will also merge their members. Since modules create both a namespace and a value, we need to understand how both merge.<br>
<br>
To merge the namespaces, type definitions from exported interfaces declared in each module are themselves merged, forming a single namespace with merged interface definitions inside.<br>
<br>
To merge the value, at each declaration site, if a module already exists with the given name, it is further extended by taking the existing module and adding the exported members of the second module to the first.
<br>
<br>
The declaration merge of &#39;Animals&#39; in this example:<br>
<div style="color:Black; background-color:White">
<pre>
module Animals {
    <span style="color:Blue">export</span> <span style="color:Blue">class</span> Zebra { }
}

module Animals {
    <span style="color:Blue">export</span> <span style="color:Blue">interface</span> Legged { numberOfLegs: number; }
    <span style="color:Blue">export</span> <span style="color:Blue">class</span> Dog { }
}
</pre>
</div>
<br>
is equivalent to:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
module Animals {
    <span style="color:Blue">export</span> <span style="color:Blue">interface</span> Legged { numberOfLegs: number; }
    
    <span style="color:Blue">export</span> <span style="color:Blue">class</span> Zebra { }
    <span style="color:Blue">export</span> <span style="color:Blue">class</span> Dog { }
}
</pre>
</div>
<br>
This model of module merging is a helpful starting place, but to get a more complete picture we need to also understand what happens with non-exported members. Non-exported members are only visible in the original (un-merged) module. This means that after merging,
 merged members that came from other declarations can not see non-exported members.<br>
<br>
We can see this more clearly in this example:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
module Animal {
    <span style="color:Blue">var</span> haveMuscles = <span style="color:Blue">true</span>;

    <span style="color:Blue">export</span> <span style="color:Blue">function</span> animalsHaveMuscles() {
        <span style="color:Blue">return</span> haveMuscles;
    }
}

module Animal {
    <span style="color:Blue">export</span> <span style="color:Blue">function</span> doAnimalsHaveMuscles() {
        <span style="color:Blue">return</span> haveMuscles;  <span style="color:Green">// &lt;-- error, haveMuscles is not visible here</span>
    }
}
</pre>
</div>
<br>
Because <span class="codeInline">haveMuscles</span> is not exported, only the <span class="codeInline">
animalsHaveMuscles</span> function that shares the same un-merged module can see the symbol. The
<span class="codeInline">doAnimalsHaveMuscles</span> function, even though it&#39;s part of the merged Animal module can not see this un-exported member.<br>
<h2 class="has-hash-nav" data-hash-nav="declaration-merging-merging-modules-with-classes-functions-and-enums">Merging Modules with Classes, Functions, and Enums</h2>
Modules are flexible enough to also merge with other types of declarations. To do so, the module declaration must follow the declaration it will merge with. The resulting declaration has properties of both declaration types. TypeScript uses this capability
 to model some of patterns in JavaScript as well as other programming languages.<br>
<br>
The first module merge we&#39;ll cover is merging a module with a class. This gives the user a way of describing inner classes.<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">class</span> Album {
    label: Album.AlbumLabel;
}
module Album {
    <span style="color:Blue">export</span> <span style="color:Blue">class</span> AlbumLabel { }
}
</pre>
</div>
<br>
The visibility rules for merged members is the same as described in the &#39;Merging Modules&#39; section, so we must export the AlbumLabel class for the merged class to see it. The end result is a class managed inside of another class. You can also use modules
 to add more static members to an existing class.<br>
<br>
In addition to the pattern of inner classes, you may also be familiar with JavaScript practice of creating a function and then extending the function further by adding properties onto the function. TypeScript uses declaration merging to build up definitions
 like this in a type-safe way. <br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> buildLabel(name: string): string {
    <span style="color:Blue">return</span> buildLabel.prefix &#43; name &#43; buildLabel.suffix;
}

module buildLabel {
    <span style="color:Blue">export</span> <span style="color:Blue">var</span> suffix = <span style="color:#A31515">&quot;&quot;</span>;
    <span style="color:Blue">export</span> <span style="color:Blue">var</span> prefix = <span style="color:#A31515">&quot;Hello, &quot;</span>;
}

alert(buildLabel(<span style="color:#A31515">&quot;Sam Smith&quot;</span>));
</pre>
</div>
<br>
Similarly, modules can be used to extend enums with static members:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">enum</span> Color {
    red = 1,
    green = 2,
    blue = 4
}

module Color {
    <span style="color:Blue">export</span> <span style="color:Blue">function</span> mixColor(colorName: string) {
        <span style="color:Blue">if</span> (colorName == <span style="color:#A31515">&quot;yellow&quot;</span>) {
            <span style="color:Blue">return</span> Color.red &#43; Color.green;
        }
        <span style="color:Blue">else</span> <span style="color:Blue">if</span> (colorName == <span style="color:#A31515">&quot;white&quot;</span>) {
            <span style="color:Blue">return</span> Color.red &#43; Color.green &#43; Color.blue;
        }
        <span style="color:Blue">else</span> <span style="color:Blue">if</span> (colorName == <span style="color:#A31515">&quot;magenta&quot;</span>) {
            <span style="color:Blue">return</span> Color.red &#43; Color.blue;
        }
        <span style="color:Blue">else</span> <span style="color:Blue">if</span> (colorName == <span style="color:#A31515">&quot;cyan&quot;</span>) {
            <span style="color:Blue">return</span> Color.green &#43; Color.blue;
        }
    }
}
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="declaration-merging-disallowed-merges">Disallowed Merges</h2>
Not all merges are allowed in TypeScript. Currently, classes can not merge with other classes, variables and classes can not merge, nor can interfaces and classes. For information on mimicking classes merging, see the
<a href="https://typescript.codeplex.com/wikipage?title=Mixins%20in%20TypeScript&referringTitle=Declaration%20Merging">
Mixins in TypeScript</a> section.<br>
<hr>
<h1 class="has-hash-nav" data-hash-nav="type-inference">Type Inference</h1>
In this section, we will cover type inference in TypeScript. Namely, we&#39;ll discuss where and how types are inferred.<br>
<h2 class="has-hash-nav" data-hash-nav="type-inference-basics">Basics</h2>
In TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation. For example, in this code<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> x = 3;
</pre>
</div>
<br>
The type of the <span class="codeInline">x</span> variable is inferred to be <span class="codeInline">
number</span>. This kind of inference takes place when initializing variables and members, setting parameter default values, and determining function return types.<br>
<br>
In most cases, type inference is straightforward. In the following sections, we&#39;ll explore some of the nuance in how types are inferred.<br>
<h2 class="has-hash-nav" data-hash-nav="type-inference-best-common-type">Best common type</h2>
When a type inference is made from several expressions, the types of those expressions are used to calculate a &quot;best common type&quot;. For example,<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> x = [0, 1, <span style="color:Blue">null</span>];
</pre>
</div>
<br>
To infer the type of <span class="codeInline">x</span> in the example above, we must consider the type of each array element. Here we are given two choices for the type of the array:
<span class="codeInline">number</span> and <span class="codeInline">null</span>. The best common type algorithm considers each candidate type, and picks the type that is compatible with all the other candidates.
<br>
<br>
Because the best common type has to be chosen from the provided candidate types, there are some cases where types share a common structure, but no one type is the super type of all candidate types. For example:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> zoo = [<span style="color:Blue">new</span> Rhino(), <span style="color:Blue">new</span> Elephant(), <span style="color:Blue">new</span> Snake()];
</pre>
</div>
<br>
Ideally, we may want <span class="codeInline">zoo</span> to be inferred as an <span class="codeInline">
Animal[]</span>, but because there is no object that is strictly of type <span class="codeInline">
Animal</span> in the array, we make no inference about the array element type. To correct this, instead explicitly provide the type when no one type is a super type of all other candidates:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> zoo: Animal[] = [<span style="color:Blue">new</span> Rhino(), <span style="color:Blue">new</span> Elephant(), <span style="color:Blue">new</span> Snake()];
</pre>
</div>
<br>
When no best common type is found, the resulting inference is the empty object type, {}. Because this type has no members, attempting to use any properties of it will cause an error. This result allows you to still use the object in a type-agnostic manner,
 while providing type safety in cases where the type of the object can&#39;t be implicitly determined.<br>
<h2 class="has-hash-nav" data-hash-nav="type-inference-contextual-type">Contextual Type</h2>
Type inference also works in &quot;the other direction&quot; in some cases in TypeScript. This is known as &quot;contextual typing&quot;. Contextual typing occurs when the type of an expression is implied by its location. For example:
<br>
<br>
<div style="color:Black; background-color:White">
<pre>
window.onmousedown = <span style="color:Blue">function</span>(mouseEvent) { 
    console.log(mouseEvent.buton);  <span style="color:Green">//&lt;- Error  </span>
};
</pre>
</div>
<br>
For the code above to give the type error, the TypeScript type checker used the type of the Window.onmousedown function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the type of the
<span class="codeInline">mouseEvent</span> parameter. If this function expression were not in a contextually typed position, the
<span class="codeInline">mouseEvent</span> parameter would have type <span class="codeInline">
any</span>, and no error would have been issued.<br>
<br>
If the contextually typed expression contains explicit type information, the contextual type is ignored. Had we written the above example:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
window.onmousedown = <span style="color:Blue">function</span>(mouseEvent: any) { 
    console.log(mouseEvent.buton);  <span style="color:Green">//&lt;- Now, no error is given  </span>
};
</pre>
</div>
<br>
The function expression with an explicit type annotation on the parameter will override the contextual type. Once it does so, no error is given as no contextual type applies.<br>
<br>
Contextual typing applies in many cases. Common cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements. The contextual type also acts as a candidate type in best
 common type. For example:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> createZoo(): Animal[] {
    <span style="color:Blue">return</span> [<span style="color:Blue">new</span> Rhino(), <span style="color:Blue">new</span> Elephant(), <span style="color:Blue">new</span> Snake()];
}
</pre>
</div>
<br>
In this example, best common type has a set of four candidates: Animal, Rhino, Elephant, and Snake. Of these, Animal can be chosen by the best common type algorithm.<br>
<br>
<br>

<h1 class="has-hash-nav" data-hash-nav="type-compatibility">Type Compatibility</h1>
Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is in contrast with nominal typing. Consider the following code:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> Named {
    name: string;
}

<span style="color:Blue">class</span> Person {
    name: string;
}

<span style="color:Blue">var</span> p: Named;
<span style="color:Green">// OK, because of structural typing</span>
p = <span style="color:Blue">new</span> Person();
</pre>
</div>
<br>
In nominally-typed languages like C# or Java, the equivalent code would be an error because the Person class does not explicitly describe itself as being an implementor of the Named interface.<br>
<br>
TypeScripts structural type system was designed based on how JavaScript code is typically written. Because JavaScript widely uses anonymous objects like function expressions and object literals, its much more natural to represent the kinds of relationships
 found in JavaScript libraries with a structural type system instead of a nominal one.<br>
<h3>A Note on Soundness</h3>
TypeScripts type system allows certain operations that cant be known at compile-time to be safe. When a type system has this property, it is said to not be sound. The places where TypeScript allows unsound behavior were carefully considered, and throughout
 this document well explain where these happen and the motivating scenarios behind them.<br>
<h2 class="has-hash-nav" data-hash-nav="type-compatibility-starting-out">Starting out</h2>
The basic rule for TypeScripts structural type system is that x is compatible with y if y has at least the same members as x. For example:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> Named {
    name: string;
}

<span style="color:Blue">var</span> x: Named;
<span style="color:Green">// ys inferred type is { name: string; location: string; }</span>
<span style="color:Blue">var</span> y = { name: <span style="color:#A31515">&#39;Alice&#39;</span>, location: <span style="color:#A31515">&#39;Seattle&#39;</span> };
x = y;
</pre>
</div>
<br>
To check whether y can be assigned to x, the compiler checks each property of x to find a corresponding compatible property in y. In this case, y must have a member called name that is a string. It does, so the assignment is allowed.<br>
<br>
The same rule for assignment is used when checking function call arguments:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> greet(n: Named) {
    alert(<span style="color:#A31515">&#39;Hello, &#39;</span> &#43; n.name);
}
greet(y); <span style="color:Green">// OK</span>
</pre>
</div>
<br>
Note that y has an extra location property, but this does not create an error. Only members of the target type (Named in this case) are considered when checking for compatibility.<br>
<br>
This comparison process proceeds recursively, exploring the type of each member and sub-member.<br>
<h2 class="has-hash-nav" data-hash-nav="type-compatibility-comparing-two-functions">Comparing two functions</h2>
While comparing primitive types and object types is relatively straightforward, the question of what kinds of functions should be considered compatible. Lets start with a basic example of two functions that differ only in their argument lists:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> x = (a: number) =&gt; 0;
<span style="color:Blue">var</span> y = (b: number, s: string) =&gt; 0;

y = x; <span style="color:Green">// OK</span>
x = y; <span style="color:Green">// Error</span>
</pre>
</div>
<br>
To check if x is assignable to y, we first look at the parameter list. Each parameter in y must have a corresponding parameter in x with a compatible type. Note that the names of the parameters are not considered, only their types. In this case, every parameter
 of x has a corresponding compatible parameter in y, so the assignment is allowed.<br>
<br>
The second assignment is an error, because y has a required second parameter that x does not have, so the assignment is disallowed.<br>
<br>
You may be wondering why we allow discarding parameters like in the example y = x. The reason is that assignment is allowed is that ignoring extra function parameters is actually quite common in JavaScript. For example, Array#forEach provides three arguments
 to the callback function: the array element, its index, and the containing array. Nevertheless, its very useful to provide a callback that only uses the first argument:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> items = [1, 2, 3];

<span style="color:Green">// Don&#39;t force these extra arguments</span>
items.forEach((item, index, array) =&gt; console.log(item));

<span style="color:Green">// Should be OK!</span>
items.forEach((item) =&gt; console.log(item));
</pre>
</div>
<br>
Now lets look at how return types are treated, using two functions that differ only by their return type:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> x = () =&gt; ({name: <span style="color:#A31515">&#39;Alice&#39;</span>});
<span style="color:Blue">var</span> y = () =&gt; ({name: <span style="color:#A31515">&#39;Alice&#39;</span>, location: <span style="color:#A31515">&#39;Seattle&#39;</span>});

x = y; <span style="color:Green">// OK</span>
y = x; <span style="color:Green">// Error because x() lacks a location property</span>
</pre>
</div>
<br>
The type system enforces that the source functions return type be a subtype of the target types return type.<br>
<h3>Function Argument Bivariance</h3>
When comparing the types of function parameters, assignment succeeds if either the source parameter is assignable to the target parameter, or vice versa. This is unsound because a caller might end up being given a function that takes a more specialized type,
 but invokes the function with a less specialized type. In practice, this sort of error is rare, and allowing this enables many common JavaScript patterns. A brief example:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">enum</span> EventType { Mouse, Keyboard }

<span style="color:Blue">interface</span> Event { timestamp: number; }
<span style="color:Blue">interface</span> MouseEvent <span style="color:Blue">extends</span> Event { x: number; y: number }
<span style="color:Blue">interface</span> KeyEvent <span style="color:Blue">extends</span> Event { keyCode: number }

<span style="color:Blue">function</span> listenEvent(eventType: EventType, handler: (n: Event) =&gt; <span style="color:Blue">void</span>) {
    <span style="color:Green">/* ... */</span>
}

<span style="color:Green">// Unsound, but useful and common</span>
listenEvent(EventType.Mouse, (e: MouseEvent) =&gt; console.log(e.x &#43; <span style="color:#A31515">&#39;,&#39;</span> &#43; e.y));

<span style="color:Green">// Undesirable alternatives in presence of soundness</span>
listenEvent(EventType.Mouse, (e: Event) =&gt; console.log((&lt;MouseEvent&gt;e).x &#43; <span style="color:#A31515">&#39;,&#39;</span> &#43; (&lt;MouseEvent&gt;e).y));
listenEvent(EventType.Mouse, &lt;(e: Event) =&gt; <span style="color:Blue">void</span>&gt;((e: MouseEvent) =&gt; console.log(e.x &#43; <span style="color:#A31515">&#39;,&#39;</span> &#43; e.y)));

<span style="color:Green">// Still disallowed (clear error). Type safety enforced for wholly incompatible types</span>
listenEvent(EventType.Mouse, (e: number) =&gt; console.log(e));
</pre>
</div>
<h3>Optional Arguments and Rest Arguments</h3>
When comparing functions for compatibility, optional and required parameters are interchangeable. Extra optional parameters of the source type are not an error, and optional parameters of the target type without corresponding parameters in the target type are
 not an error.<br>
<br>
When a function has a rest parameter, it is treated as if it were an infinite series of optional parameters.<br>
<br>
This is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing undefined in that position is equivalent for most functions.<br>
<br>
The motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">function</span> invokeLater(args: any[], callback: (...args: any[]) =&gt; <span style="color:Blue">void</span>) {
    <span style="color:Green">/* ... Invoke callback with &#39;args&#39; ... */</span>
}

<span style="color:Green">// Unsound - invokeLater &quot;might&quot; provide any number of arguments</span>
invokeLater([1, 2], (x, y) =&gt; console.log(x &#43; <span style="color:#A31515">&#39;, &#39;</span> &#43; y));

<span style="color:Green">// Confusing (x and y are actually required) and undiscoverable</span>
invokeLater([1, 2], (x?, y?) =&gt; console.log(x &#43; <span style="color:#A31515">&#39;, &#39;</span> &#43; y));
</pre>
</div>
<h3>Functions with overloads</h3>
When a function has overloads, each overload in the source type must be matched by a compatible signature on the target type. This ensures that the target function can be called in all the same situations as the source function. Functions with specialized overload
 signatures (those that use string literals in their overloads) do not use their specialized signatures when checking for compatibility.<br>
<h2 class="has-hash-nav" data-hash-nav="type-compatibility-enums">Enums</h2>
Enums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">enum</span> Status { Ready, Waiting };
<span style="color:Blue">enum</span> Color { Red, Blue, Green };

<span style="color:Blue">var</span> status = Status.Ready;
status = Color.Green;  <span style="color:Green">//error</span>
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="type-compatibility-classes">Classes</h2>
Classes work similarly to object literal types and interfaces with one exception: they have both a static and an instance type. When comparing two objects of a class type, only members of the instance are compared. Static members and constructors do not affect
 compatibility. <br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">class</span> Animal {
    feet: number;
    constructor(name: string, numFeet: number) { }
}

<span style="color:Blue">class</span> Size {
    feet: number;
    constructor(numFeet: number) { }
}

<span style="color:Blue">var</span> a: Animal;
<span style="color:Blue">var</span> s: Size;

a = s;  <span style="color:Green">//OK</span>
s = a;  <span style="color:Green">//OK</span>
</pre>
</div>
<h3>Private members in classes</h3>
Private members in a class affect their compatibility. When an instance of a class is checked for compatibility, if it contains a private member, the target type must also contain a private member that originated from the same class. This allows, for example,
 a class to be assignment compatible with its super class but not with classes from a different inheritance hierarchy which otherwise have the same shape.<br>
<h2 class="has-hash-nav" data-hash-nav="type-compatibility-generics">Generics</h2>
Because TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member. For example,<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> Empty&lt;T&gt; {
}
<span style="color:Blue">var</span> x: Empty&lt;number&gt;;
<span style="color:Blue">var</span> y: Empty&lt;string&gt;;

x = y;  <span style="color:Green">// okay, y matches structure of x</span>
</pre>
</div>
<br>
In the above, x and y are compatible because their structures do not use the type argument in a differentiating way. Changing this example by adding a member to Empty&lt;T&gt; shows how this works:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> NotEmpty&lt;T&gt; {
    data: T;
}
<span style="color:Blue">var</span> x: NotEmpty&lt;number&gt;;
<span style="color:Blue">var</span> y: NotEmpty&lt;string&gt;;

x = y;  <span style="color:Green">// error, x and y are not compatible</span>
</pre>
</div>
<br>
In this way, a generic type that has its type arguments specified acts just like a non-generic type.<br>
<br>
For generic types that do not have their type arguments specified, compatibility is checked by specifying &#39;any&#39; in place of all unspecified type arguments. The resulting types are then checked for compatibility, just as in the non-generic case.<br>
<br>
For example,<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> identity = <span style="color:Blue">function</span>&lt;T&gt;(x: T): T { 
    <span style="color:Green">// ...</span>
}

<span style="color:Blue">var</span> reverse = <span style="color:Blue">function</span>&lt;U&gt;(y: U): U {
    <span style="color:Green">// ...</span>
}

identity = reverse;  <span style="color:Green">// Okay because (x: any)=&gt;any matches (y: any)=&gt;any</span>
</pre>
</div>
<h2 class="has-hash-nav" data-hash-nav="type-compatibility-advanced-topics">Advanced Topics</h2>
<h3>Subtype vs Assignment</h3>
So far, we&#39;ve used &#39;compatible&#39;, which is not a term defined in the language spec. In TypeScript, there are two kinds of compatibility: subtype and assignment. These differ only in that assignment extends subtype compatibility with rules to allow
 assignment to and from &#39;any&#39; and to and from enum with corresponding numeric values.
<br>
<br>
Different places in the language use one of the two compatibility mechanisms, depending on the situation. For practical purposes, type compatibility is dictated by assignment compatibility even in the cases of the
<span class="codeInline">implements</span> and <span class="codeInline">extends</span> clauses. For more information, see the
<a href="http://go.microsoft.com/fwlink/?LinkId=267121">TypeScript spec</a>.<br>

<h1 class="has-hash-nav" data-hash-nav="writing-dts-files">Writing .d.ts files</h1>
When using an external JavaScript library, or new host API, you&#39;ll need to use a declaration file (.d.ts) to describe the shape of that library. This guide covers a few high-level concepts specific to writing definition files, then proceeds with a number
 of examples that show how to transcribe various concepts to their matching definition file descriptions.<br>
<h2 class="has-hash-nav" data-hash-nav="writing-dts-files-guidelines-and-specifics">Guidelines and Specifics</h2>
<h3>Workflow</h3>
The best way to write a .d.ts file is to start from the documentation of the library, not the code. Working from the documentation ensures the surface you present isn&#39;t muddied with implementation details, and is typically much easier to read than JS code.
 The examples below will be written as if you were reading documentation that presented example calling code.<br>
<h3>Namespacing</h3>
When defining interfaces (for example, &quot;options&quot; objects), you have a choice about whether to put these types inside a module or not. This is largely a judgement call -- if the consumer is likely to often declare variables or parameters of that type,
 and the type can be named without risk of colliding with other types, prefer placing it in the global namespace. If the type is not likely to be referenced directly, or can&#39;t be named with a reasonably unique name, do use a module to prevent it from colliding
 with other types.<br>
<h3>Callbacks</h3>
Many JavaScript libraries take a function as a parameter, then invoke that function later with a known set of arguments. When writing the function signatures for these types,
<b>do not</b> mark those parameters as optional. The right way to think of this is
<i>&quot;What parameters will be provided?&quot;</i>, not <i>&quot;What parameters will be consumed?&quot;</i>. While TypeScript 0.9.7 and above does not enforce that the optionality, bivariance on argument optionality might be enforced by an external linter.<br>
<h3>Extensibility and Declaration Merging</h3>
When writing definition files, it&#39;s important to remember TypeScript&#39;s rules for extending existing objects. You might have a choice of declaring a variable using an anonymous type or an interface type:<br>
<br>
<b>Anonymously-typed var</b><br>
<br>
<div style="color:Black; background-color:White">
<pre>
declare <span style="color:Blue">var</span> MyPoint: { x: number; y: number; };
</pre>
</div>
<br>
<b>Interfaced-typed var</b><br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> SomePoint { x: number; y: number; }
declare <span style="color:Blue">var</span> MyPoint: SomePoint;
</pre>
</div>
<br>
From a consumption side these declarations are identical, but the type <span class="codeInline">
SomePoint</span> can be extended through interface merging:<br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> SomePoint { z: number; }
MyPoint.z = 4; <span style="color:Green">// OK</span>
</pre>
</div>
<br>
Whether or not you want your declarations to be extensible in this way is a bit of a judgement call. As always, try to represent the intent of the library here.<br>
<h3>Class Decomposition</h3>
Classes in TypeScript create two separate types: the instance type, which defines what members an instance of a class has, and the constructor function type, which defines what members the class constructor function has. The constructor function type is also
 known as the &quot;static side&quot; type because it includes static members of the class.<br>
<br>
While you can reference the static side of a class using the <span class="codeInline">
typeof</span> keyword, it is sometimes useful or necessary when writing definition files to use the
<i>decomposed class</i> pattern which explicitly separates the instance and static types of class.<br>
<br>
As an example, the following two declarations are nearly equivalent from a consumption perspective:<br>
<br>
<b>Standard</b><br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">class</span> A {
    <span style="color:Blue">static</span> st: string;
    inst: number;
    constructor(m: any) {}
}
</pre>
</div>
<br>
<b>Decomposed</b><br>
<br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> A_Static {
    <span style="color:Blue">new</span>(m: any): A_Instance;
    st: string;
}
<span style="color:Blue">interface</span> A_Instance {
    inst: number;
}
declare <span style="color:Blue">var</span> A: A_Static;
</pre>
</div>
<br>
The trade-offs here are as follows:
<ul>
<li>Standard classes can be inherited from using <span class="codeInline">extends</span>; decomposed classes cannot. This might change in later version of TypeScript if arbitrary
<span class="codeInline">extends</span> expressions are allowed. </li><li>It is possible to add members later (through declaration merging) to the static side of both standard and decomposed classes
</li><li>It is possible to add instance members to decomposed classes, but not standard classes
</li><li>You&#39;ll need to come up with sensible names for more types when writing a decomposed class</li></ul>
<h3>Naming Conventions</h3>
In general, do not prefix interfaces with <span class="codeInline">I</span> (e.g.
<span class="codeInline">IColor</span>). Because the concept of an interface in TypeScript is much more broad than in C# or Java, the
<span class="codeInline">IFoo</span> naming convention is not broadly useful.<br>
<h2 class="has-hash-nav" data-hash-nav="writing-dts-files-examples">Examples</h2>
Let&#39;s jump in to the examples section. For each example, sample <i>usage</i> of the library is provided, followed by the definition code that accurately types the usage. When there are multiple good representations, more than one definition sample might
 be listed.<br>
<h3>Options Objects</h3>
<b>Usage</b><br>
<div style="color:Black; background-color:White">
<pre>
animalFactory.create(<span style="color:#A31515">&quot;dog&quot;</span>);
animalFactory.create(<span style="color:#A31515">&quot;giraffe&quot;</span>, { name: <span style="color:#A31515">&quot;ronald&quot;</span> });
animalFactory.create(<span style="color:#A31515">&quot;panda&quot;</span>, { name: <span style="color:#A31515">&quot;bob&quot;</span>, height: 400 });
<span style="color:Green">// Invalid: name must be provided if options is given</span>
animalFactory.create(<span style="color:#A31515">&quot;cat&quot;</span>, { height: 32 });
</pre>
</div>
<br>
<b>Typing</b><br>
<div style="color:Black; background-color:White">
<pre>
module animalFactory {
    <span style="color:Blue">interface</span> AnimalOptions {
        name: string;
        height?: number;
        weight?: number;
    }
    <span style="color:Blue">function</span> create(name: string, animalOptions?: AnimalOptions): Animal;
}
</pre>
</div>
<h3>Functions with Properties</h3>
<b>Usage</b><br>
<div style="color:Black; background-color:White">
<pre>
zooKeeper.workSchedule = <span style="color:#A31515">&quot;morning&quot;</span>;
zooKeeper(giraffeCage);
</pre>
</div>
<br>
<b>Typing</b><br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Green">// Note: Function must precede module</span>
<span style="color:Blue">function</span> zooKeeper(cage: AnimalCage);
module zooKeeper {
    <span style="color:Blue">var</span> workSchedule: string;
}
</pre>
</div>
<h3>New &#43; callable methods</h3>
<b>Usage</b><br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">var</span> w = widget(32, 16);
<span style="color:Blue">var</span> y = <span style="color:Blue">new</span> widget(<span style="color:#A31515">&quot;sprocket&quot;</span>);
<span style="color:Green">// w and y are both widgets</span>
w.sprock();
y.sprock();
</pre>
</div>
<br>
<b>Typing</b><br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Blue">interface</span> Widget {
    sprock(): <span style="color:Blue">void</span>;
}

<span style="color:Blue">interface</span> WidgetFactory {
    <span style="color:Blue">new</span>(name: string): Widget;
    (width: number, height: number): Widget;
}

declare <span style="color:Blue">var</span> widget: WidgetFactory;
</pre>
</div>
<h3>Global / External-agnostic Libraries</h3>
<b>Usage</b><br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Green">// Either</span>
<span style="color:Blue">import</span> x = require(<span style="color:#A31515">&#39;zoo&#39;</span>);
x.open();
<span style="color:Green">// or</span>
zoo.open();
</pre>
</div>
<br>
<b>Typing</b><br>
<div style="color:Black; background-color:White">
<pre>
module zoo {
  <span style="color:Blue">function</span> open(): <span style="color:Blue">void</span>;
}

declare module <span style="color:#A31515">&quot;zoo&quot;</span> {
    <span style="color:Blue">export</span> = zoo;
}
</pre>
</div>
<h3>Single Complex Object in External Modules</h3>
<b>Usage</b><br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Green">// Super-chainable library for eagles</span>
<span style="color:Blue">import</span> eagle = require(<span style="color:#A31515">&#39;./eagle&#39;</span>);
<span style="color:Green">// Call directly</span>
eagle(<span style="color:#A31515">&#39;bald&#39;</span>).fly();
<span style="color:Green">// Invoke with new</span>
<span style="color:Blue">var</span> eddie = <span style="color:Blue">new</span> eagle(1000);
<span style="color:Green">// Set properties</span>
eagle.favorite = <span style="color:#A31515">&#39;golden&#39;</span>;
</pre>
</div>
<br>
<b>Typing</b><br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Green">// Note: can use any name here, but has to be the same throughout this file</span>
declare <span style="color:Blue">function</span> eagle(name: string): eagle;
declare module eagle {
    <span style="color:Blue">var</span> favorite: string;
    <span style="color:Blue">function</span> fly(): <span style="color:Blue">void</span>;
}
<span style="color:Blue">interface</span> eagle {
    <span style="color:Blue">new</span>(awesomeness: number): eagle;
}

<span style="color:Blue">export</span> = eagle;
</pre>
</div>
<h3>Callbacks</h3>
<b>Usage</b><br>
<div style="color:Black; background-color:White">
<pre>
addLater(3, 4, (x) =&gt; console.log(<span style="color:#A31515">&#39;x = &#39;</span> &#43; x));
</pre>
</div>
<br>
<b>Typing</b><br>
<div style="color:Black; background-color:White">
<pre>
<span style="color:Green">// Note: &#39;void&#39; return type is preferred here</span>
<span style="color:Blue">function</span> addLater(x: number, y: number, (sum: number) =&gt; <span style="color:Blue">void</span>): <span style="color:Blue">void</span>;
</pre>
</div>
<br>
Please post a comment <a href="https://typescript.codeplex.com/wikipage?title=https%3a%2f%2fgithub.com%2fMicrosoft%2fTypeScript%2fissues&referringTitle=Writing%20Definition%20%28.d.ts%29%20Files">
here</a> if there&#39;s a pattern you&#39;d like to see documented! We&#39;ll add to this as we can.

            </div> <!-- .row -->
        </div> <!-- .center-container -->
    </div> <!-- outer container -->
</div>

<script type="text/javascript" src="/script/HandbookNav.js">
</script>

    <div class="copyright">
        <a href="http://go.microsoft.com/fwlink/?LinkId=264945">Privacy Statement</a> | <a href="/Terms" target="_blank">Terms of Use</a> | <a href="http://go.microsoft.com/fwlink/?LinkId=264947">Trademarks</a> &copy; 2012 - 2015 <img src="../Content/images/microsoft_logo_90x16.png" alt="Microsoft Logo" /><br />
    </div>
    <script src="/script/hashnav.js" type="text/javascript"></script>
    <script type="text/javascript">
    var gDomain = "m.webtrends.com";
    var gDcsId = "dcsjwb9vb00000c932fd0rjc7_5p3t";
    var gFpc = "WT_FPC";
    var gTrackEvents = "1";
    if (document.cookie.indexOf(gFpc + "=") == -1) { document.write("<SCR" + "IPT TYPE='text/javascript' SRC='" + "//" + gDomain + "/" + gDcsId + "/wtid.js" + "'><\/SCR" + "IPT>"); }
    </script>
    <script type="text/javascript" src="//js.microsoft.com/library/mnp/2/wt/js/wt.js"></script><noscript><img border="0" name="DCSIMG" width="1" height="1" src="//m.webtrends.com/dcsjwb9vb00000c932fd0rjc7_5p3t/njs.gif?dcsuri=/nojavascript&amp;WT.js=No"></noscript>

   
</body>
</html>